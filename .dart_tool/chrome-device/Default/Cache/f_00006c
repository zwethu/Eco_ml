<<<<<<< HEAD
define(['dart_sdk', 'packages/flutter/src/painting/borders.dart', 'packages/flutter/src/painting/edge_insets.dart', 'packages/flutter/src/painting/border_radius.dart'], (function load__packages__flutter__src__material__input_border_dart(dart_sdk, packages__flutter__src__painting__borders$46dart, packages__flutter__src__painting__edge_insets$46dart, packages__flutter__src__painting__border_radius$46dart) {
  'use strict';
  const core = dart_sdk.core;
  const ui = dart_sdk.ui;
  const math = dart_sdk.math;
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  const borders = packages__flutter__src__painting__borders$46dart.src__painting__borders;
  const edge_insets = packages__flutter__src__painting__edge_insets$46dart.src__painting__edge_insets;
  const border_radius = packages__flutter__src__painting__border_radius$46dart.src__painting__border_radius;
  var input_border = Object.create(dart.library);
  var $runtimeType = dartx.runtimeType;
  var $clamp = dartx.clamp;
  dart._checkModuleNullSafetyMode(true);
=======
define(['dart_sdk', 'packages/flutter/src/painting/basic_types.dart', 'packages/flutter/src/rendering/sliver.dart', 'packages/flutter/src/rendering/layer.dart', 'packages/flutter/src/foundation/debug.dart', 'packages/flutter/src/painting/edge_insets.dart'], (function load__packages__flutter__src__rendering__sliver_padding_dart(dart_sdk, packages__flutter__src__painting__basic_types$46dart, packages__flutter__src__rendering__sliver$46dart, packages__flutter__src__rendering__layer$46dart, packages__flutter__src__foundation__debug$46dart, packages__flutter__src__painting__edge_insets$46dart) {
  'use strict';
  const core = dart_sdk.core;
  const math = dart_sdk.math;
  const ui = dart_sdk.ui;
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  const basic_types = packages__flutter__src__painting__basic_types$46dart.src__painting__basic_types;
  const sliver = packages__flutter__src__rendering__sliver$46dart.src__rendering__sliver;
  const object = packages__flutter__src__rendering__layer$46dart.src__rendering__object;
  const debug = packages__flutter__src__rendering__layer$46dart.src__rendering__debug;
  const diagnostics = packages__flutter__src__foundation__debug$46dart.src__foundation__diagnostics;
  const edge_insets = packages__flutter__src__painting__edge_insets$46dart.src__painting__edge_insets;
  var sliver_padding = Object.create(dart.library);
  var $_equals = dartx._equals;
  dart._checkModuleNullSafetyMode(true);
  var T = {
    VoidTobool: () => (T.VoidTobool = dart.constFn(dart.fnType(core.bool, [])))(),
    DiagnosticsPropertyOfEdgeInsetsGeometry: () => (T.DiagnosticsPropertyOfEdgeInsetsGeometry = dart.constFn(diagnostics.DiagnosticsProperty$(edge_insets.EdgeInsetsGeometry)))(),
    EnumPropertyOfTextDirection: () => (T.EnumPropertyOfTextDirection = dart.constFn(diagnostics.EnumProperty$(ui.TextDirection)))()
  };
>>>>>>> 75a5b68328961ba989f4b72e23f0c2c5b16d7dc4
  const CT = Object.create({
    _: () => (C, CT)
  });
  dart.defineLazy(CT, {
<<<<<<< HEAD
    get C1() {
      return C[1] = dart.const({
        __proto__: borders.BorderStyle.prototype,
        [_name]: "BorderStyle.none",
        index: 0
=======
    get C0() {
      return C[0] = dart.const({
        __proto__: basic_types.AxisDirection.prototype,
        [_name]: "AxisDirection.up",
        index: 0
      });
    },
    get C1() {
      return C[1] = dart.const({
        __proto__: basic_types.AxisDirection.prototype,
        [_name]: "AxisDirection.right",
        index: 1
>>>>>>> 75a5b68328961ba989f4b72e23f0c2c5b16d7dc4
      });
    },
    get C2() {
      return C[2] = dart.const({
<<<<<<< HEAD
        __proto__: ui.Color.prototype,
        [Color_value]: 4278190080.0
      });
    },
    get C0() {
      return C[0] = dart.const({
        __proto__: borders.BorderSide.prototype,
        [BorderSide_style]: C[1] || CT.C1,
        [BorderSide_width]: 0,
        [BorderSide_color]: C[2] || CT.C2
=======
        __proto__: basic_types.AxisDirection.prototype,
        [_name]: "AxisDirection.down",
        index: 2
>>>>>>> 75a5b68328961ba989f4b72e23f0c2c5b16d7dc4
      });
    },
    get C3() {
      return C[3] = dart.const({
<<<<<<< HEAD
        __proto__: input_border._NoInputBorder.prototype,
        [borderSide$]: C[0] || CT.C0
      });
    },
    get C5() {
      return C[5] = dart.const({
        __proto__: borders.BorderStyle.prototype,
        [_name]: "BorderStyle.solid",
        index: 1
=======
        __proto__: basic_types.AxisDirection.prototype,
        [_name]: "AxisDirection.left",
        index: 3
>>>>>>> 75a5b68328961ba989f4b72e23f0c2c5b16d7dc4
      });
    },
    get C4() {
      return C[4] = dart.const({
<<<<<<< HEAD
        __proto__: borders.BorderSide.prototype,
        [BorderSide_style]: C[5] || CT.C5,
        [BorderSide_width]: 1,
        [BorderSide_color]: C[2] || CT.C2
      });
    },
    get C7() {
      return C[7] = dart.const({
        __proto__: ui.Radius.prototype,
        [Radius_y]: 0,
        [Radius_x]: 0
      });
    },
    get C8() {
      return C[8] = dart.const({
        __proto__: ui.Radius.prototype,
        [Radius_y]: 4,
        [Radius_x]: 4
      });
    },
    get C6() {
      return C[6] = dart.const({
        __proto__: border_radius.BorderRadius.prototype,
        [BorderRadius_bottomRight]: C[7] || CT.C7,
        [BorderRadius_bottomLeft]: C[7] || CT.C7,
        [BorderRadius_topRight]: C[8] || CT.C8,
        [BorderRadius_topLeft]: C[8] || CT.C8
      });
    },
    get C9() {
      return C[9] = dart.const({
        __proto__: border_radius.BorderRadius.prototype,
        [BorderRadius_bottomRight]: C[8] || CT.C8,
        [BorderRadius_bottomLeft]: C[8] || CT.C8,
        [BorderRadius_topRight]: C[8] || CT.C8,
        [BorderRadius_topLeft]: C[8] || CT.C8
      });
    },
    get C10() {
      return C[10] = dart.const({
        __proto__: ui.TextDirection.prototype,
        [_name$]: "TextDirection.rtl",
        index: 0
      });
    },
    get C11() {
      return C[11] = dart.const({
        __proto__: ui.TextDirection.prototype,
        [_name$]: "TextDirection.ltr",
=======
        __proto__: basic_types.Axis.prototype,
        [_name]: "Axis.horizontal",
        index: 0
      });
    },
    get C5() {
      return C[5] = dart.const({
        __proto__: basic_types.Axis.prototype,
        [_name]: "Axis.vertical",
>>>>>>> 75a5b68328961ba989f4b72e23f0c2c5b16d7dc4
        index: 1
      });
    }
  }, false);
<<<<<<< HEAD
  var C = Array(12).fill(void 0);
  var I = [
    "file:///D:/DevelpmentTool/flutter/packages/flutter/lib/src/material/input_border.dart",
    "package:flutter/src/material/input_border.dart"
  ];
  var borderSide$ = dart.privateName(input_border, "InputBorder.borderSide");
  var _name = dart.privateName(borders, "_name");
  var BorderSide_style = dart.privateName(borders, "BorderSide.style");
  var BorderSide_width = dart.privateName(borders, "BorderSide.width");
  var Color_value = dart.privateName(ui, "Color.value");
  var BorderSide_color = dart.privateName(borders, "BorderSide.color");
  input_border.InputBorder = class InputBorder extends borders.ShapeBorder {
    get borderSide() {
      return this[borderSide$];
    }
    set borderSide(value) {
      super.borderSide = value;
    }
  };
  (input_border.InputBorder.new = function(opts) {
    let borderSide = opts && 'borderSide' in opts ? opts.borderSide : C[0] || CT.C0;
    this[borderSide$] = borderSide;
    if (!(borderSide !== null)) dart.assertFailed(null, I[0], 39, 15, "borderSide != null");
    input_border.InputBorder.__proto__.new.call(this);
    ;
  }).prototype = input_border.InputBorder.prototype;
  dart.addTypeTests(input_border.InputBorder);
  dart.addTypeCaches(input_border.InputBorder);
  dart.setLibraryUri(input_border.InputBorder, I[1]);
  dart.setFieldSignature(input_border.InputBorder, () => ({
    __proto__: dart.getFields(input_border.InputBorder.__proto__),
    borderSide: dart.finalFieldType(borders.BorderSide)
  }));
  dart.defineLazy(input_border.InputBorder, {
    /*input_border.InputBorder.none*/get none() {
      return C[3] || CT.C3;
    }
  }, false);
  input_border._NoInputBorder = class _NoInputBorder extends input_border.InputBorder {
    copyWith(opts) {
      let borderSide = opts && 'borderSide' in opts ? opts.borderSide : null;
      return C[3] || CT.C3;
    }
    get isOutline() {
      return false;
    }
    get dimensions() {
      return edge_insets.EdgeInsets.zero;
    }
    scale(t) {
      return C[3] || CT.C3;
    }
    getInnerPath(rect, opts) {
      let t0;
      let textDirection = opts && 'textDirection' in opts ? opts.textDirection : null;
      t0 = ui.Path.new();
      return (() => {
        t0.addRect(rect);
        return t0;
      })();
    }
    getOuterPath(rect, opts) {
      let t0;
      let textDirection = opts && 'textDirection' in opts ? opts.textDirection : null;
      t0 = ui.Path.new();
      return (() => {
        t0.addRect(rect);
        return t0;
      })();
    }
    paint(canvas, rect, opts) {
      let gapStart = opts && 'gapStart' in opts ? opts.gapStart : null;
      let gapExtent = opts && 'gapExtent' in opts ? opts.gapExtent : 0;
      let gapPercentage = opts && 'gapPercentage' in opts ? opts.gapPercentage : 0;
      let textDirection = opts && 'textDirection' in opts ? opts.textDirection : null;
    }
  };
  (input_border._NoInputBorder.new = function() {
    input_border._NoInputBorder.__proto__.new.call(this, {borderSide: borders.BorderSide.none});
    ;
  }).prototype = input_border._NoInputBorder.prototype;
  dart.addTypeTests(input_border._NoInputBorder);
  dart.addTypeCaches(input_border._NoInputBorder);
  dart.setMethodSignature(input_border._NoInputBorder, () => ({
    __proto__: dart.getMethods(input_border._NoInputBorder.__proto__),
    copyWith: dart.fnType(input_border._NoInputBorder, [], {borderSide: dart.nullable(borders.BorderSide)}, {}),
    scale: dart.fnType(input_border._NoInputBorder, [core.double]),
    getInnerPath: dart.fnType(ui.Path, [ui.Rect], {textDirection: dart.nullable(ui.TextDirection)}, {}),
    getOuterPath: dart.fnType(ui.Path, [ui.Rect], {textDirection: dart.nullable(ui.TextDirection)}, {}),
    paint: dart.fnType(dart.void, [ui.Canvas, ui.Rect], {gapExtent: core.double, gapPercentage: core.double, gapStart: dart.nullable(core.double), textDirection: dart.nullable(ui.TextDirection)}, {})
  }));
  dart.setGetterSignature(input_border._NoInputBorder, () => ({
    __proto__: dart.getGetters(input_border._NoInputBorder.__proto__),
    isOutline: core.bool,
    dimensions: edge_insets.EdgeInsetsGeometry
  }));
  dart.setLibraryUri(input_border._NoInputBorder, I[1]);
  var borderRadius$ = dart.privateName(input_border, "UnderlineInputBorder.borderRadius");
  var Radius_y = dart.privateName(ui, "Radius.y");
  var Radius_x = dart.privateName(ui, "Radius.x");
  var BorderRadius_bottomRight = dart.privateName(border_radius, "BorderRadius.bottomRight");
  var BorderRadius_bottomLeft = dart.privateName(border_radius, "BorderRadius.bottomLeft");
  var BorderRadius_topRight = dart.privateName(border_radius, "BorderRadius.topRight");
  var BorderRadius_topLeft = dart.privateName(border_radius, "BorderRadius.topLeft");
  input_border.UnderlineInputBorder = class UnderlineInputBorder extends input_border.InputBorder {
    get borderRadius() {
      return this[borderRadius$];
    }
    set borderRadius(value) {
      super.borderRadius = value;
    }
    get isOutline() {
      return false;
    }
    copyWith(opts) {
      let t0, t0$;
      let borderSide = opts && 'borderSide' in opts ? opts.borderSide : null;
      let borderRadius = opts && 'borderRadius' in opts ? opts.borderRadius : null;
      return new input_border.UnderlineInputBorder.new({borderSide: (t0 = borderSide, t0 == null ? this.borderSide : t0), borderRadius: (t0$ = borderRadius, t0$ == null ? this.borderRadius : t0$)});
    }
    get dimensions() {
      return new edge_insets.EdgeInsets.only({bottom: this.borderSide.width});
    }
    scale(t) {
      return new input_border.UnderlineInputBorder.new({borderSide: this.borderSide.scale(t)});
    }
    getInnerPath(rect, opts) {
      let t0;
      let textDirection = opts && 'textDirection' in opts ? opts.textDirection : null;
      t0 = ui.Path.new();
      return (() => {
        t0.addRect(new ui.Rect.fromLTWH(rect.left, rect.top, rect.width, math.max(core.double, 0.0, rect.height - this.borderSide.width)));
        return t0;
      })();
    }
    getOuterPath(rect, opts) {
      let t0;
      let textDirection = opts && 'textDirection' in opts ? opts.textDirection : null;
      t0 = ui.Path.new();
      return (() => {
        t0.addRRect(this.borderRadius.resolve(textDirection).toRRect(rect));
        return t0;
      })();
    }
    lerpFrom(a, t) {
      if (input_border.UnderlineInputBorder.is(a)) {
        return new input_border.UnderlineInputBorder.new({borderSide: borders.BorderSide.lerp(a.borderSide, this.borderSide, t), borderRadius: dart.nullCheck(border_radius.BorderRadius.lerp(a.borderRadius, this.borderRadius, t))});
      }
      return super.lerpFrom(a, t);
    }
    lerpTo(b, t) {
      if (input_border.UnderlineInputBorder.is(b)) {
        return new input_border.UnderlineInputBorder.new({borderSide: borders.BorderSide.lerp(this.borderSide, b.borderSide, t), borderRadius: dart.nullCheck(border_radius.BorderRadius.lerp(this.borderRadius, b.borderRadius, t))});
      }
      return super.lerpTo(b, t);
    }
    paint(canvas, rect, opts) {
      let gapStart = opts && 'gapStart' in opts ? opts.gapStart : null;
      let gapExtent = opts && 'gapExtent' in opts ? opts.gapExtent : 0;
      let gapPercentage = opts && 'gapPercentage' in opts ? opts.gapPercentage : 0;
      let textDirection = opts && 'textDirection' in opts ? opts.textDirection : null;
      if (!this.borderRadius.bottomLeft._equals(ui.Radius.zero) || !this.borderRadius.bottomRight._equals(ui.Radius.zero)) canvas.clipPath(this.getOuterPath(rect, {textDirection: textDirection}));
      canvas.drawLine(rect.bottomLeft, rect.bottomRight, this.borderSide.toPaint());
    }
    _equals(other) {
      if (other == null) return false;
      if (this === other) return true;
      if (!other[$runtimeType]._equals(this[$runtimeType])) return false;
      return input_border.InputBorder.is(other) && other.borderSide._equals(this.borderSide);
    }
    get hashCode() {
      return this.borderSide.hashCode;
    }
  };
  (input_border.UnderlineInputBorder.new = function(opts) {
    let borderSide = opts && 'borderSide' in opts ? opts.borderSide : C[4] || CT.C4;
    let borderRadius = opts && 'borderRadius' in opts ? opts.borderRadius : C[6] || CT.C6;
    this[borderRadius$] = borderRadius;
    if (!(borderRadius !== null)) dart.assertFailed(null, I[0], 151, 15, "borderRadius != null");
    input_border.UnderlineInputBorder.__proto__.new.call(this, {borderSide: borderSide});
    ;
  }).prototype = input_border.UnderlineInputBorder.prototype;
  dart.addTypeTests(input_border.UnderlineInputBorder);
  dart.addTypeCaches(input_border.UnderlineInputBorder);
  dart.setMethodSignature(input_border.UnderlineInputBorder, () => ({
    __proto__: dart.getMethods(input_border.UnderlineInputBorder.__proto__),
    copyWith: dart.fnType(input_border.UnderlineInputBorder, [], {borderRadius: dart.nullable(border_radius.BorderRadius), borderSide: dart.nullable(borders.BorderSide)}, {}),
    scale: dart.fnType(input_border.UnderlineInputBorder, [core.double]),
    getInnerPath: dart.fnType(ui.Path, [ui.Rect], {textDirection: dart.nullable(ui.TextDirection)}, {}),
    getOuterPath: dart.fnType(ui.Path, [ui.Rect], {textDirection: dart.nullable(ui.TextDirection)}, {}),
    paint: dart.fnType(dart.void, [ui.Canvas, ui.Rect], {gapExtent: core.double, gapPercentage: core.double, gapStart: dart.nullable(core.double), textDirection: dart.nullable(ui.TextDirection)}, {})
  }));
  dart.setGetterSignature(input_border.UnderlineInputBorder, () => ({
    __proto__: dart.getGetters(input_border.UnderlineInputBorder.__proto__),
    isOutline: core.bool,
    dimensions: edge_insets.EdgeInsetsGeometry
  }));
  dart.setLibraryUri(input_border.UnderlineInputBorder, I[1]);
  dart.setFieldSignature(input_border.UnderlineInputBorder, () => ({
    __proto__: dart.getFields(input_border.UnderlineInputBorder.__proto__),
    borderRadius: dart.finalFieldType(border_radius.BorderRadius)
  }));
  dart.defineExtensionMethods(input_border.UnderlineInputBorder, ['_equals']);
  dart.defineExtensionAccessors(input_border.UnderlineInputBorder, ['hashCode']);
  var gapPadding$ = dart.privateName(input_border, "OutlineInputBorder.gapPadding");
  var borderRadius$0 = dart.privateName(input_border, "OutlineInputBorder.borderRadius");
  var _gapBorderPath = dart.privateName(input_border, "_gapBorderPath");
  var _name$ = dart.privateName(ui, "_name");
  input_border.OutlineInputBorder = class OutlineInputBorder extends input_border.InputBorder {
    get gapPadding() {
      return this[gapPadding$];
    }
    set gapPadding(value) {
      super.gapPadding = value;
    }
    get borderRadius() {
      return this[borderRadius$0];
    }
    set borderRadius(value) {
      super.borderRadius = value;
    }
    static _cornersAreCircular(borderRadius) {
      return borderRadius.topLeft.x === borderRadius.topLeft.y && borderRadius.bottomLeft.x === borderRadius.bottomLeft.y && borderRadius.topRight.x === borderRadius.topRight.y && borderRadius.bottomRight.x === borderRadius.bottomRight.y;
    }
    get isOutline() {
      return true;
    }
    copyWith(opts) {
      let t0, t0$, t0$0;
      let borderSide = opts && 'borderSide' in opts ? opts.borderSide : null;
      let borderRadius = opts && 'borderRadius' in opts ? opts.borderRadius : null;
      let gapPadding = opts && 'gapPadding' in opts ? opts.gapPadding : null;
      return new input_border.OutlineInputBorder.new({borderSide: (t0 = borderSide, t0 == null ? this.borderSide : t0), borderRadius: (t0$ = borderRadius, t0$ == null ? this.borderRadius : t0$), gapPadding: (t0$0 = gapPadding, t0$0 == null ? this.gapPadding : t0$0)});
    }
    get dimensions() {
      return new edge_insets.EdgeInsets.all(this.borderSide.width);
    }
    scale(t) {
      return new input_border.OutlineInputBorder.new({borderSide: this.borderSide.scale(t), borderRadius: this.borderRadius['*'](t), gapPadding: this.gapPadding * t});
    }
    lerpFrom(a, t) {
      if (input_border.OutlineInputBorder.is(a)) {
        let outline = a;
        return new input_border.OutlineInputBorder.new({borderRadius: dart.nullCheck(border_radius.BorderRadius.lerp(outline.borderRadius, this.borderRadius, t)), borderSide: borders.BorderSide.lerp(outline.borderSide, this.borderSide, t), gapPadding: outline.gapPadding});
      }
      return super.lerpFrom(a, t);
    }
    lerpTo(b, t) {
      if (input_border.OutlineInputBorder.is(b)) {
        let outline = b;
        return new input_border.OutlineInputBorder.new({borderRadius: dart.nullCheck(border_radius.BorderRadius.lerp(this.borderRadius, outline.borderRadius, t)), borderSide: borders.BorderSide.lerp(this.borderSide, outline.borderSide, t), gapPadding: outline.gapPadding});
      }
      return super.lerpTo(b, t);
    }
    getInnerPath(rect, opts) {
      let t0;
      let textDirection = opts && 'textDirection' in opts ? opts.textDirection : null;
      t0 = ui.Path.new();
      return (() => {
        t0.addRRect(this.borderRadius.resolve(textDirection).toRRect(rect).deflate(this.borderSide.width));
        return t0;
      })();
    }
    getOuterPath(rect, opts) {
      let t0;
      let textDirection = opts && 'textDirection' in opts ? opts.textDirection : null;
      t0 = ui.Path.new();
      return (() => {
        t0.addRRect(this.borderRadius.resolve(textDirection).toRRect(rect));
        return t0;
      })();
    }
    [_gapBorderPath](canvas, center, start, extent) {
      let t0, t0$, t0$0;
      let scaledRRect = center.scaleRadii();
      let tlCorner = new ui.Rect.fromLTWH(scaledRRect.left, scaledRRect.top, scaledRRect.tlRadiusX * 2.0, scaledRRect.tlRadiusY * 2.0);
      let trCorner = new ui.Rect.fromLTWH(scaledRRect.right - scaledRRect.trRadiusX * 2.0, scaledRRect.top, scaledRRect.trRadiusX * 2.0, scaledRRect.trRadiusY * 2.0);
      let brCorner = new ui.Rect.fromLTWH(scaledRRect.right - scaledRRect.brRadiusX * 2.0, scaledRRect.bottom - scaledRRect.brRadiusY * 2.0, scaledRRect.brRadiusX * 2.0, scaledRRect.brRadiusY * 2.0);
      let blCorner = new ui.Rect.fromLTWH(scaledRRect.left, scaledRRect.bottom - scaledRRect.blRadiusY * 2.0, scaledRRect.blRadiusX * 2.0, scaledRRect.blRadiusX * 2.0);
      let tlCornerArcSweep = start < scaledRRect.tlRadiusX ? math.asin((start / scaledRRect.tlRadiusX)[$clamp](-1.0, 1.0)) : 3.141592653589793 / 2.0;
      let path = (t0 = ui.Path.new(), (() => {
        t0.addArc(tlCorner, 3.141592653589793, tlCornerArcSweep);
        t0.moveTo(scaledRRect.left + scaledRRect.tlRadiusX, scaledRRect.top);
        return t0;
      })());
      if (start > scaledRRect.tlRadiusX) path.lineTo(scaledRRect.left + start, scaledRRect.top);
      if (start + extent < scaledRRect.width - scaledRRect.trRadiusX) {
        t0$ = path;
        (() => {
          t0$.relativeMoveTo(extent, 0.0);
          t0$.lineTo(scaledRRect.right - scaledRRect.trRadiusX, scaledRRect.top);
          t0$.addArc(trCorner, 4.71238898038469, 1.5707963267948966);
          return t0$;
        })();
      } else if (start + extent < scaledRRect.width) {
        let dx = scaledRRect.width - (start + extent);
        let sweep = math.acos(dx / scaledRRect.trRadiusX);
        path.addArc(trCorner, 4.71238898038469 + sweep, 1.5707963267948966 - sweep);
      }
      t0$0 = path;
      return (() => {
        t0$0.moveTo(scaledRRect.right, scaledRRect.top + scaledRRect.trRadiusY);
        t0$0.lineTo(scaledRRect.right, scaledRRect.bottom - scaledRRect.brRadiusY);
        t0$0.addArc(brCorner, 0.0, 1.5707963267948966);
        t0$0.lineTo(scaledRRect.left + scaledRRect.blRadiusX, scaledRRect.bottom);
        t0$0.addArc(blCorner, 3.141592653589793 / 2.0, 1.5707963267948966);
        t0$0.lineTo(scaledRRect.left, scaledRRect.top + scaledRRect.tlRadiusY);
        return t0$0;
      })();
    }
    paint(canvas, rect, opts) {
      let gapStart = opts && 'gapStart' in opts ? opts.gapStart : null;
      let gapExtent = opts && 'gapExtent' in opts ? opts.gapExtent : 0;
      let gapPercentage = opts && 'gapPercentage' in opts ? opts.gapPercentage : 0;
      let textDirection = opts && 'textDirection' in opts ? opts.textDirection : null;
      if (!(gapExtent !== null)) dart.assertFailed(null, I[0], 469, 12, "gapExtent != null");
      if (!(gapPercentage >= 0.0 && gapPercentage <= 1.0)) dart.assertFailed(null, I[0], 470, 12, "gapPercentage >= 0.0 && gapPercentage <= 1.0");
      if (!input_border.OutlineInputBorder._cornersAreCircular(this.borderRadius)) dart.assertFailed(null, I[0], 471, 12, "_cornersAreCircular(borderRadius)");
      let paint = this.borderSide.toPaint();
      let outer = this.borderRadius.toRRect(rect);
      let center = outer.deflate(this.borderSide.width / 2.0);
      if (gapStart == null || gapExtent <= 0.0 || gapPercentage === 0.0) {
        canvas.drawRRect(center, paint);
      } else {
        let extent = dart.nullCheck(ui.lerpDouble(0.0, gapExtent + this.gapPadding * 2.0, gapPercentage));
        switch (dart.nullCheck(textDirection)) {
          case C[10] || CT.C10:
          {
            let path = this[_gapBorderPath](canvas, center, math.max(core.double, 0.0, dart.notNull(gapStart) + this.gapPadding - extent), extent);
            canvas.drawPath(path, paint);
            break;
          }
          case C[11] || CT.C11:
          {
            let path = this[_gapBorderPath](canvas, center, math.max(core.double, 0.0, dart.notNull(gapStart) - this.gapPadding), extent);
            canvas.drawPath(path, paint);
            break;
          }
        }
      }
    }
    _equals(other) {
      if (other == null) return false;
      if (this === other) return true;
      if (!other[$runtimeType]._equals(this[$runtimeType])) return false;
      return input_border.OutlineInputBorder.is(other) && other.borderSide._equals(this.borderSide) && other.borderRadius._equals(this.borderRadius) && other.gapPadding === this.gapPadding;
    }
    get hashCode() {
      return ui.hashValues(this.borderSide, this.borderRadius, this.gapPadding);
    }
  };
  (input_border.OutlineInputBorder.new = function(opts) {
    let borderSide = opts && 'borderSide' in opts ? opts.borderSide : C[4] || CT.C4;
    let borderRadius = opts && 'borderRadius' in opts ? opts.borderRadius : C[9] || CT.C9;
    let gapPadding = opts && 'gapPadding' in opts ? opts.gapPadding : 4;
    this[borderRadius$0] = borderRadius;
    this[gapPadding$] = gapPadding;
    if (!(borderRadius !== null)) dart.assertFailed(null, I[0], 290, 15, "borderRadius != null");
    if (!(gapPadding !== null && gapPadding >= 0.0)) dart.assertFailed(null, I[0], 291, 15, "gapPadding != null && gapPadding >= 0.0");
    input_border.OutlineInputBorder.__proto__.new.call(this, {borderSide: borderSide});
    ;
  }).prototype = input_border.OutlineInputBorder.prototype;
  dart.addTypeTests(input_border.OutlineInputBorder);
  dart.addTypeCaches(input_border.OutlineInputBorder);
  dart.setMethodSignature(input_border.OutlineInputBorder, () => ({
    __proto__: dart.getMethods(input_border.OutlineInputBorder.__proto__),
    copyWith: dart.fnType(input_border.OutlineInputBorder, [], {borderRadius: dart.nullable(border_radius.BorderRadius), borderSide: dart.nullable(borders.BorderSide), gapPadding: dart.nullable(core.double)}, {}),
    scale: dart.fnType(input_border.OutlineInputBorder, [core.double]),
    getInnerPath: dart.fnType(ui.Path, [ui.Rect], {textDirection: dart.nullable(ui.TextDirection)}, {}),
    getOuterPath: dart.fnType(ui.Path, [ui.Rect], {textDirection: dart.nullable(ui.TextDirection)}, {}),
    [_gapBorderPath]: dart.fnType(ui.Path, [ui.Canvas, ui.RRect, core.double, core.double]),
    paint: dart.fnType(dart.void, [ui.Canvas, ui.Rect], {gapExtent: core.double, gapPercentage: core.double, gapStart: dart.nullable(core.double), textDirection: dart.nullable(ui.TextDirection)}, {})
  }));
  dart.setGetterSignature(input_border.OutlineInputBorder, () => ({
    __proto__: dart.getGetters(input_border.OutlineInputBorder.__proto__),
    isOutline: core.bool,
    dimensions: edge_insets.EdgeInsetsGeometry
  }));
  dart.setLibraryUri(input_border.OutlineInputBorder, I[1]);
  dart.setFieldSignature(input_border.OutlineInputBorder, () => ({
    __proto__: dart.getFields(input_border.OutlineInputBorder.__proto__),
    gapPadding: dart.finalFieldType(core.double),
    borderRadius: dart.finalFieldType(border_radius.BorderRadius)
  }));
  dart.defineExtensionMethods(input_border.OutlineInputBorder, ['_equals']);
  dart.defineExtensionAccessors(input_border.OutlineInputBorder, ['hashCode']);
  dart.trackLibraries("packages/flutter/src/material/input_border.dart", {
    "package:flutter/src/material/input_border.dart": input_border
  }, {
  }, '{"version":3,"sourceRoot":"","sources":["input_border.dart"],"names":[],"mappings":"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","file":"../../../../../../../packages/flutter/src/material/input_border.dart.lib.js"}');
  // Exports:
  return {
    src__material__input_border: input_border
  };
}));

//# sourceMappingURL=input_border.dart.lib.js.map
=======
  var C = Array(6).fill(void 0);
  var I = [
    "file:///D:/DevTools/flutter/packages/flutter/lib/src/rendering/sliver_padding.dart",
    "package:flutter/src/rendering/sliver_padding.dart"
  ];
  var _name = dart.privateName(basic_types, "_name");
  const RenderSliver_RenderObjectWithChildMixin$36 = class RenderSliver_RenderObjectWithChildMixin extends sliver.RenderSliver {};
  (RenderSliver_RenderObjectWithChildMixin$36.new = function() {
    object.RenderObjectWithChildMixin$(sliver.RenderSliver)[dart.mixinNew].call(this);
    RenderSliver_RenderObjectWithChildMixin$36.__proto__.new.call(this);
  }).prototype = RenderSliver_RenderObjectWithChildMixin$36.prototype;
  dart.applyMixin(RenderSliver_RenderObjectWithChildMixin$36, object.RenderObjectWithChildMixin$(sliver.RenderSliver));
  sliver_padding.RenderSliverEdgeInsetsPadding = class RenderSliverEdgeInsetsPadding extends RenderSliver_RenderObjectWithChildMixin$36 {
    get beforePadding() {
      if (!(this.constraints !== null)) dart.assertFailed(null, I[0], 38, 12, "constraints != null");
      if (!(this.constraints.axisDirection !== null)) dart.assertFailed(null, I[0], 39, 12, "constraints.axisDirection != null");
      if (!(this.constraints.growthDirection !== null)) dart.assertFailed(null, I[0], 40, 12, "constraints.growthDirection != null");
      if (!(this.resolvedPadding != null)) dart.assertFailed(null, I[0], 41, 12, "resolvedPadding != null");
      switch (sliver.applyGrowthDirectionToAxisDirection(this.constraints.axisDirection, this.constraints.growthDirection)) {
        case C[0] || CT.C0:
        {
          return dart.nullCheck(this.resolvedPadding).bottom;
        }
        case C[1] || CT.C1:
        {
          return dart.nullCheck(this.resolvedPadding).left;
        }
        case C[2] || CT.C2:
        {
          return dart.nullCheck(this.resolvedPadding).top;
        }
        case C[3] || CT.C3:
        {
          return dart.nullCheck(this.resolvedPadding).right;
        }
      }
    }
    get afterPadding() {
      if (!(this.constraints !== null)) dart.assertFailed(null, I[0], 59, 12, "constraints != null");
      if (!(this.constraints.axisDirection !== null)) dart.assertFailed(null, I[0], 60, 12, "constraints.axisDirection != null");
      if (!(this.constraints.growthDirection !== null)) dart.assertFailed(null, I[0], 61, 12, "constraints.growthDirection != null");
      if (!(this.resolvedPadding != null)) dart.assertFailed(null, I[0], 62, 12, "resolvedPadding != null");
      switch (sliver.applyGrowthDirectionToAxisDirection(this.constraints.axisDirection, this.constraints.growthDirection)) {
        case C[0] || CT.C0:
        {
          return dart.nullCheck(this.resolvedPadding).top;
        }
        case C[1] || CT.C1:
        {
          return dart.nullCheck(this.resolvedPadding).right;
        }
        case C[2] || CT.C2:
        {
          return dart.nullCheck(this.resolvedPadding).bottom;
        }
        case C[3] || CT.C3:
        {
          return dart.nullCheck(this.resolvedPadding).left;
        }
      }
    }
    get mainAxisPadding() {
      if (!(this.constraints !== null)) dart.assertFailed(null, I[0], 82, 12, "constraints != null");
      if (!(this.constraints.axis !== null)) dart.assertFailed(null, I[0], 83, 12, "constraints.axis != null");
      if (!(this.resolvedPadding != null)) dart.assertFailed(null, I[0], 84, 12, "resolvedPadding != null");
      return dart.nullCheck(this.resolvedPadding).along(this.constraints.axis);
    }
    get crossAxisPadding() {
      if (!(this.constraints !== null)) dart.assertFailed(null, I[0], 95, 12, "constraints != null");
      if (!(this.constraints.axis !== null)) dart.assertFailed(null, I[0], 96, 12, "constraints.axis != null");
      if (!(this.resolvedPadding != null)) dart.assertFailed(null, I[0], 97, 12, "resolvedPadding != null");
      switch (this.constraints.axis) {
        case C[4] || CT.C4:
        {
          return dart.nullCheck(this.resolvedPadding).vertical;
        }
        case C[5] || CT.C5:
        {
          return dart.nullCheck(this.resolvedPadding).horizontal;
        }
      }
    }
    setupParentData(child) {
      object.RenderObject.as(child);
      if (!sliver.SliverPhysicalParentData.is(child.parentData)) child.parentData = new sliver.SliverPhysicalParentData.new();
    }
    performLayout() {
      let constraints = this.constraints;
      if (!(this.resolvedPadding != null)) dart.assertFailed(null, I[0], 115, 12, "resolvedPadding != null");
      let beforePadding = this.beforePadding;
      let afterPadding = this.afterPadding;
      let mainAxisPadding = this.mainAxisPadding;
      let crossAxisPadding = this.crossAxisPadding;
      if (this.child == null) {
        this.geometry = new sliver.SliverGeometry.new({scrollExtent: mainAxisPadding, paintExtent: math.min(core.double, mainAxisPadding, constraints.remainingPaintExtent), maxPaintExtent: mainAxisPadding});
        return;
      }
      let beforePaddingPaintExtent = this.calculatePaintOffset(constraints, {from: 0.0, to: beforePadding});
      let overlap = constraints.overlap;
      if (overlap > 0) {
        overlap = math.max(core.double, 0.0, constraints.overlap - beforePaddingPaintExtent);
      }
      dart.nullCheck(this.child).layout(constraints.copyWith({scrollOffset: math.max(core.double, 0.0, constraints.scrollOffset - beforePadding), cacheOrigin: math.min(core.double, 0.0, constraints.cacheOrigin + beforePadding), overlap: overlap, remainingPaintExtent: constraints.remainingPaintExtent - this.calculatePaintOffset(constraints, {from: 0.0, to: beforePadding}), remainingCacheExtent: constraints.remainingCacheExtent - this.calculateCacheOffset(constraints, {from: 0.0, to: beforePadding}), crossAxisExtent: math.max(core.double, 0.0, constraints.crossAxisExtent - crossAxisPadding), precedingScrollExtent: beforePadding + constraints.precedingScrollExtent}), {parentUsesSize: true});
      let childLayoutGeometry = dart.nullCheck(dart.nullCheck(this.child).geometry);
      if (childLayoutGeometry.scrollOffsetCorrection != null) {
        this.geometry = new sliver.SliverGeometry.new({scrollOffsetCorrection: childLayoutGeometry.scrollOffsetCorrection});
        return;
      }
      let afterPaddingPaintExtent = this.calculatePaintOffset(constraints, {from: beforePadding + childLayoutGeometry.scrollExtent, to: mainAxisPadding + childLayoutGeometry.scrollExtent});
      let mainAxisPaddingPaintExtent = beforePaddingPaintExtent + afterPaddingPaintExtent;
      let beforePaddingCacheExtent = this.calculateCacheOffset(constraints, {from: 0.0, to: beforePadding});
      let afterPaddingCacheExtent = this.calculateCacheOffset(constraints, {from: beforePadding + childLayoutGeometry.scrollExtent, to: mainAxisPadding + childLayoutGeometry.scrollExtent});
      let mainAxisPaddingCacheExtent = afterPaddingCacheExtent + beforePaddingCacheExtent;
      let paintExtent = math.min(core.double, beforePaddingPaintExtent + math.max(core.num, childLayoutGeometry.paintExtent, childLayoutGeometry.layoutExtent + afterPaddingPaintExtent), constraints.remainingPaintExtent);
      this.geometry = new sliver.SliverGeometry.new({paintOrigin: childLayoutGeometry.paintOrigin, scrollExtent: mainAxisPadding + childLayoutGeometry.scrollExtent, paintExtent: paintExtent, layoutExtent: math.min(core.double, mainAxisPaddingPaintExtent + childLayoutGeometry.layoutExtent, paintExtent), cacheExtent: math.min(core.double, mainAxisPaddingCacheExtent + childLayoutGeometry.cacheExtent, constraints.remainingCacheExtent), maxPaintExtent: mainAxisPadding + childLayoutGeometry.maxPaintExtent, hitTestExtent: math.max(core.double, mainAxisPaddingPaintExtent + childLayoutGeometry.paintExtent, beforePaddingPaintExtent + childLayoutGeometry.hitTestExtent), hasVisualOverflow: childLayoutGeometry.hasVisualOverflow});
      let childParentData = sliver.SliverPhysicalParentData.as(dart.nullCheck(dart.nullCheck(this.child).parentData));
      if (!(constraints.axisDirection !== null)) dart.assertFailed(null, I[0], 192, 12, "constraints.axisDirection != null");
      if (!(constraints.growthDirection !== null)) dart.assertFailed(null, I[0], 193, 12, "constraints.growthDirection != null");
      switch (sliver.applyGrowthDirectionToAxisDirection(constraints.axisDirection, constraints.growthDirection)) {
        case C[0] || CT.C0:
        {
          childParentData.paintOffset = new ui.Offset.new(dart.nullCheck(this.resolvedPadding).left, this.calculatePaintOffset(constraints, {from: dart.nullCheck(this.resolvedPadding).bottom + childLayoutGeometry.scrollExtent, to: dart.nullCheck(this.resolvedPadding).bottom + childLayoutGeometry.scrollExtent + dart.nullCheck(this.resolvedPadding).top}));
          break;
        }
        case C[1] || CT.C1:
        {
          childParentData.paintOffset = new ui.Offset.new(this.calculatePaintOffset(constraints, {from: 0.0, to: dart.nullCheck(this.resolvedPadding).left}), dart.nullCheck(this.resolvedPadding).top);
          break;
        }
        case C[2] || CT.C2:
        {
          childParentData.paintOffset = new ui.Offset.new(dart.nullCheck(this.resolvedPadding).left, this.calculatePaintOffset(constraints, {from: 0.0, to: dart.nullCheck(this.resolvedPadding).top}));
          break;
        }
        case C[3] || CT.C3:
        {
          childParentData.paintOffset = new ui.Offset.new(this.calculatePaintOffset(constraints, {from: dart.nullCheck(this.resolvedPadding).right + childLayoutGeometry.scrollExtent, to: dart.nullCheck(this.resolvedPadding).right + childLayoutGeometry.scrollExtent + dart.nullCheck(this.resolvedPadding).left}), dart.nullCheck(this.resolvedPadding).top);
          break;
        }
      }
      if (!(childParentData.paintOffset !== null)) dart.assertFailed(null, I[0], 208, 12, "childParentData.paintOffset != null");
      if (!(beforePadding === this.beforePadding)) dart.assertFailed(null, I[0], 209, 12, "beforePadding == this.beforePadding");
      if (!(afterPadding === this.afterPadding)) dart.assertFailed(null, I[0], 210, 12, "afterPadding == this.afterPadding");
      if (!(mainAxisPadding === this.mainAxisPadding)) dart.assertFailed(null, I[0], 211, 12, "mainAxisPadding == this.mainAxisPadding");
      if (!(crossAxisPadding === this.crossAxisPadding)) dart.assertFailed(null, I[0], 212, 12, "crossAxisPadding == this.crossAxisPadding");
    }
    hitTestChildren(result, opts) {
      let mainAxisPosition = opts && 'mainAxisPosition' in opts ? opts.mainAxisPosition : null;
      let crossAxisPosition = opts && 'crossAxisPosition' in opts ? opts.crossAxisPosition : null;
      if (this.child != null && dart.nullCheck(dart.nullCheck(this.child).geometry).hitTestExtent > 0.0) {
        let childParentData = sliver.SliverPhysicalParentData.as(dart.nullCheck(dart.nullCheck(this.child).parentData));
        result.addWithAxisOffset({mainAxisPosition: mainAxisPosition, crossAxisPosition: crossAxisPosition, mainAxisOffset: this.childMainAxisPosition(dart.nullCheck(this.child)), crossAxisOffset: this.childCrossAxisPosition(dart.nullCheck(this.child)), paintOffset: childParentData.paintOffset, hitTest: dart.bind(dart.nullCheck(this.child), 'hitTest')});
      }
      return false;
    }
    childMainAxisPosition(child) {
      sliver.RenderSliver.as(child);
      if (!(child !== null)) dart.assertFailed(null, I[0], 233, 12, "child != null");
      if (!child[$_equals](this.child)) dart.assertFailed(null, I[0], 234, 12, "child == this.child");
      return this.calculatePaintOffset(this.constraints, {from: 0.0, to: this.beforePadding});
    }
    childCrossAxisPosition(child) {
      sliver.RenderSliver.as(child);
      if (!(child !== null)) dart.assertFailed(null, I[0], 240, 12, "child != null");
      if (!child[$_equals](this.child)) dart.assertFailed(null, I[0], 241, 12, "child == this.child");
      if (!(this.constraints !== null)) dart.assertFailed(null, I[0], 242, 12, "constraints != null");
      if (!(this.constraints.axisDirection !== null)) dart.assertFailed(null, I[0], 243, 12, "constraints.axisDirection != null");
      if (!(this.constraints.growthDirection !== null)) dart.assertFailed(null, I[0], 244, 12, "constraints.growthDirection != null");
      if (!(this.resolvedPadding != null)) dart.assertFailed(null, I[0], 245, 12, "resolvedPadding != null");
      switch (sliver.applyGrowthDirectionToAxisDirection(this.constraints.axisDirection, this.constraints.growthDirection)) {
        case C[0] || CT.C0:
        case C[2] || CT.C2:
        {
          return dart.nullCheck(this.resolvedPadding).left;
        }
        case C[3] || CT.C3:
        case C[1] || CT.C1:
        {
          return dart.nullCheck(this.resolvedPadding).top;
        }
      }
    }
    childScrollOffset(child) {
      object.RenderObject.as(child);
      if (!dart.equals(child.parent, this)) dart.assertFailed(null, I[0], 258, 12, "child.parent == this");
      return this.beforePadding;
    }
    applyPaintTransform(child, transform) {
      object.RenderObject.as(child);
      if (!(child !== null)) dart.assertFailed(null, I[0], 264, 12, "child != null");
      if (!child[$_equals](this.child)) dart.assertFailed(null, I[0], 265, 12, "child == this.child");
      let childParentData = sliver.SliverPhysicalParentData.as(dart.nullCheck(child.parentData));
      childParentData.applyPaintTransform(transform);
    }
    paint(context, offset) {
      if (this.child != null && dart.nullCheck(dart.nullCheck(this.child).geometry).visible) {
        let childParentData = sliver.SliverPhysicalParentData.as(dart.nullCheck(dart.nullCheck(this.child).parentData));
        context.paintChild(dart.nullCheck(this.child), offset['+'](childParentData.paintOffset));
      }
    }
    debugPaint(context, offset) {
      super.debugPaint(context, offset);
      if (!dart.fn(() => {
        if (debug.debugPaintSizeEnabled) {
          let parentSize = this.getAbsoluteSize();
          let outerRect = offset['&'](parentSize);
          let innerRect = null;
          if (this.child != null) {
            let childSize = dart.nullCheck(this.child).getAbsoluteSize();
            let childParentData = sliver.SliverPhysicalParentData.as(dart.nullCheck(dart.nullCheck(this.child).parentData));
            innerRect = offset['+'](childParentData.paintOffset)['&'](childSize);
            if (!(innerRect.top >= outerRect.top)) dart.assertFailed(null, I[0], 290, 18, "innerRect.top >= outerRect.top");
            if (!(innerRect.left >= outerRect.left)) dart.assertFailed(null, I[0], 291, 18, "innerRect.left >= outerRect.left");
            if (!(innerRect.right <= outerRect.right)) dart.assertFailed(null, I[0], 292, 18, "innerRect.right <= outerRect.right");
            if (!(innerRect.bottom <= outerRect.bottom)) dart.assertFailed(null, I[0], 293, 18, "innerRect.bottom <= outerRect.bottom");
          }
          debug.debugPaintPadding(context.canvas, outerRect, innerRect);
        }
        return true;
      }, T.VoidTobool())()) dart.assertFailed(null, I[0], 281, 12, "() {\r\n      if (debugPaintSizeEnabled) {\r\n        final Size parentSize = getAbsoluteSize();\r\n        final Rect outerRect = offset & parentSize;\r\n        Rect? innerRect;\r\n        if (child != null) {\r\n          final Size childSize = child!.getAbsoluteSize();\r\n          final SliverPhysicalParentData childParentData = child!.parentData! as SliverPhysicalParentData;\r\n          innerRect = (offset + childParentData.paintOffset) & childSize;\r\n          assert(innerRect.top >= outerRect.top);\r\n          assert(innerRect.left >= outerRect.left);\r\n          assert(innerRect.right <= outerRect.right);\r\n          assert(innerRect.bottom <= outerRect.bottom);\r\n        }\r\n        debugPaintPadding(context.canvas, outerRect, innerRect);\r\n      }\r\n      return true;\r\n    }()");
    }
  };
  (sliver_padding.RenderSliverEdgeInsetsPadding.new = function() {
    sliver_padding.RenderSliverEdgeInsetsPadding.__proto__.new.call(this);
    ;
  }).prototype = sliver_padding.RenderSliverEdgeInsetsPadding.prototype;
  dart.addTypeTests(sliver_padding.RenderSliverEdgeInsetsPadding);
  dart.addTypeCaches(sliver_padding.RenderSliverEdgeInsetsPadding);
  dart.setMethodSignature(sliver_padding.RenderSliverEdgeInsetsPadding, () => ({
    __proto__: dart.getMethods(sliver_padding.RenderSliverEdgeInsetsPadding.__proto__),
    performLayout: dart.fnType(dart.void, [])
  }));
  dart.setGetterSignature(sliver_padding.RenderSliverEdgeInsetsPadding, () => ({
    __proto__: dart.getGetters(sliver_padding.RenderSliverEdgeInsetsPadding.__proto__),
    beforePadding: core.double,
    afterPadding: core.double,
    mainAxisPadding: core.double,
    crossAxisPadding: core.double
  }));
  dart.setLibraryUri(sliver_padding.RenderSliverEdgeInsetsPadding, I[1]);
  var _resolvedPadding = dart.privateName(sliver_padding, "_resolvedPadding");
  var _padding = dart.privateName(sliver_padding, "_padding");
  var _textDirection = dart.privateName(sliver_padding, "_textDirection");
  var _resolve = dart.privateName(sliver_padding, "_resolve");
  var _markNeedsResolution = dart.privateName(sliver_padding, "_markNeedsResolution");
  sliver_padding.RenderSliverPadding = class RenderSliverPadding extends sliver_padding.RenderSliverEdgeInsetsPadding {
    get resolvedPadding() {
      return this[_resolvedPadding];
    }
    [_resolve]() {
      if (this.resolvedPadding != null) return;
      this[_resolvedPadding] = this.padding.resolve(this.textDirection);
      if (!dart.nullCheck(this.resolvedPadding).isNonNegative) dart.assertFailed(null, I[0], 332, 12, "resolvedPadding!.isNonNegative");
    }
    [_markNeedsResolution]() {
      this[_resolvedPadding] = null;
      this.markNeedsLayout();
    }
    get padding() {
      return this[_padding];
    }
    set padding(value) {
      if (!(value !== null)) dart.assertFailed(null, I[0], 347, 12, "value != null");
      if (!this.padding.isNonNegative) dart.assertFailed(null, I[0], 348, 12, "padding.isNonNegative");
      if (this[_padding]._equals(value)) return;
      this[_padding] = value;
      this[_markNeedsResolution]();
    }
    get textDirection() {
      return this[_textDirection];
    }
    set textDirection(value) {
      if (this[_textDirection] == value) return;
      this[_textDirection] = value;
      this[_markNeedsResolution]();
    }
    performLayout() {
      this[_resolve]();
      super.performLayout();
    }
    debugFillProperties(properties) {
      super.debugFillProperties(properties);
      properties.add(new (T.DiagnosticsPropertyOfEdgeInsetsGeometry()).new("padding", this.padding));
      properties.add(new (T.EnumPropertyOfTextDirection()).new("textDirection", this.textDirection, {defaultValue: null}));
    }
  };
  (sliver_padding.RenderSliverPadding.new = function(opts) {
    let padding = opts && 'padding' in opts ? opts.padding : null;
    let textDirection = opts && 'textDirection' in opts ? opts.textDirection : null;
    let child = opts && 'child' in opts ? opts.child : null;
    this[_resolvedPadding] = null;
    if (!(padding !== null)) dart.assertFailed(null, I[0], 317, 15, "padding != null");
    if (!padding.isNonNegative) dart.assertFailed(null, I[0], 318, 15, "padding.isNonNegative");
    this[_padding] = padding;
    this[_textDirection] = textDirection;
    sliver_padding.RenderSliverPadding.__proto__.new.call(this);
    this.child = child;
  }).prototype = sliver_padding.RenderSliverPadding.prototype;
  dart.addTypeTests(sliver_padding.RenderSliverPadding);
  dart.addTypeCaches(sliver_padding.RenderSliverPadding);
  dart.setMethodSignature(sliver_padding.RenderSliverPadding, () => ({
    __proto__: dart.getMethods(sliver_padding.RenderSliverPadding.__proto__),
    [_resolve]: dart.fnType(dart.void, []),
    [_markNeedsResolution]: dart.fnType(dart.void, [])
  }));
  dart.setGetterSignature(sliver_padding.RenderSliverPadding, () => ({
    __proto__: dart.getGetters(sliver_padding.RenderSliverPadding.__proto__),
    resolvedPadding: dart.nullable(edge_insets.EdgeInsets),
    padding: edge_insets.EdgeInsetsGeometry,
    textDirection: dart.nullable(ui.TextDirection)
  }));
  dart.setSetterSignature(sliver_padding.RenderSliverPadding, () => ({
    __proto__: dart.getSetters(sliver_padding.RenderSliverPadding.__proto__),
    padding: edge_insets.EdgeInsetsGeometry,
    textDirection: dart.nullable(ui.TextDirection)
  }));
  dart.setLibraryUri(sliver_padding.RenderSliverPadding, I[1]);
  dart.setFieldSignature(sliver_padding.RenderSliverPadding, () => ({
    __proto__: dart.getFields(sliver_padding.RenderSliverPadding.__proto__),
    [_resolvedPadding]: dart.fieldType(dart.nullable(edge_insets.EdgeInsets)),
    [_padding]: dart.fieldType(edge_insets.EdgeInsetsGeometry),
    [_textDirection]: dart.fieldType(dart.nullable(ui.TextDirection))
  }));
  dart.trackLibraries("packages/flutter/src/rendering/sliver_padding.dart", {
    "package:flutter/src/rendering/sliver_padding.dart": sliver_padding
  }, {
  }, '{"version":3,"sourceRoot":"","sources":["sliver_padding.dart"],"names":[],"mappings":"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","file":"../../../../../../../packages/flutter/src/rendering/sliver_padding.dart.lib.js"}');
  // Exports:
  return {
    src__rendering__sliver_padding: sliver_padding
  };
}));

//# sourceMappingURL=sliver_padding.dart.lib.js.map
>>>>>>> 75a5b68328961ba989f4b72e23f0c2c5b16d7dc4

<<<<<<< HEAD
define(['dart_sdk', 'packages/flutter/src/rendering/layer.dart', 'packages/flutter/src/semantics/semantics.dart', 'packages/flutter/src/painting/placeholder_span.dart', 'packages/flutter/src/painting/basic_types.dart', 'packages/flutter/src/gestures/hit_test.dart', 'packages/vector_math/vector_math_64.dart', 'packages/flutter/src/services/text_editing.dart', 'packages/flutter/src/gestures/tap.dart', 'packages/flutter/src/gestures/multitap.dart', 'packages/flutter/src/gestures/long_press.dart', 'packages/flutter/src/foundation/debug.dart', 'packages/flutter/src/painting/strut_style.dart'], (function load__packages__flutter__src__rendering__paragraph_dart(dart_sdk, packages__flutter__src__rendering__layer$46dart, packages__flutter__src__semantics__semantics$46dart, packages__flutter__src__painting__placeholder_span$46dart, packages__flutter__src__painting__basic_types$46dart, packages__flutter__src__gestures__hit_test$46dart, packages__vector_math__vector_math_64$46dart, packages__flutter__src__services__text_editing$46dart, packages__flutter__src__gestures__tap$46dart, packages__flutter__src__gestures__multitap$46dart, packages__flutter__src__gestures__long_press$46dart, packages__flutter__src__foundation__debug$46dart, packages__flutter__src__painting__strut_style$46dart) {
=======
define(['dart_sdk', 'packages/flutter/src/painting/borders.dart', 'packages/flutter/src/foundation/debug.dart', 'packages/flutter/src/painting/edge_insets.dart', 'packages/flutter/src/foundation/object.dart', 'packages/flutter/src/painting/border_radius.dart'], (function load__packages__flutter__src__painting__box_border_dart(dart_sdk, packages__flutter__src__painting__borders$46dart, packages__flutter__src__foundation__debug$46dart, packages__flutter__src__painting__edge_insets$46dart, packages__flutter__src__foundation__object$46dart, packages__flutter__src__painting__border_radius$46dart) {
>>>>>>> 75a5b68328961ba989f4b72e23f0c2c5b16d7dc4
  'use strict';
  const core = dart_sdk.core;
  const _interceptors = dart_sdk._interceptors;
  const ui = dart_sdk.ui;
<<<<<<< HEAD
  const _internal = dart_sdk._internal;
  const collection = dart_sdk.collection;
  const math = dart_sdk.math;
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  const box = packages__flutter__src__rendering__layer$46dart.src__rendering__box;
  const object = packages__flutter__src__rendering__layer$46dart.src__rendering__object;
  const debug = packages__flutter__src__rendering__layer$46dart.src__rendering__debug;
  const semantics = packages__flutter__src__semantics__semantics$46dart.src__semantics__semantics;
  const text_painter = packages__flutter__src__painting__placeholder_span$46dart.src__painting__text_painter;
  const placeholder_span = packages__flutter__src__painting__placeholder_span$46dart.src__painting__placeholder_span;
  const inline_span = packages__flutter__src__painting__placeholder_span$46dart.src__painting__inline_span;
  const text_span = packages__flutter__src__painting__placeholder_span$46dart.src__painting__text_span;
  const basic_types = packages__flutter__src__painting__basic_types$46dart.src__painting__basic_types;
  const hit_test = packages__flutter__src__gestures__hit_test$46dart.src__gestures__hit_test;
  const vector_math_64 = packages__vector_math__vector_math_64$46dart.vector_math_64;
  const text_editing = packages__flutter__src__services__text_editing$46dart.src__services__text_editing;
  const tap = packages__flutter__src__gestures__tap$46dart.src__gestures__tap;
  const multitap = packages__flutter__src__gestures__multitap$46dart.src__gestures__multitap;
  const long_press = packages__flutter__src__gestures__long_press$46dart.src__gestures__long_press;
  const diagnostics = packages__flutter__src__foundation__debug$46dart.src__foundation__diagnostics;
  const strut_style = packages__flutter__src__painting__strut_style$46dart.src__painting__strut_style;
  var paragraph = Object.create(dart.library);
  var $add = dartx.add;
  var $join = dartx.join;
  var $_get = dartx._get;
  var $_set = dartx._set;
  var $length = dartx.length;
  var $abs = dartx.abs;
  var $any = dartx.any;
  var $isNotEmpty = dartx.isNotEmpty;
  var $elementAt = dartx.elementAt;
  var $isEmpty = dartx.isEmpty;
  var $first = dartx.first;
  var $skip = dartx.skip;
  var $floorToDouble = dartx.floorToDouble;
  var $ceilToDouble = dartx.ceilToDouble;
  var $runtimeType = dartx.runtimeType;
  dart._checkModuleNullSafetyMode(true);
  var T = {
    JSArrayOfString: () => (T.JSArrayOfString = dart.constFn(_interceptors.JSArray$(core.String)))(),
    JSArrayOfPlaceholderSpan: () => (T.JSArrayOfPlaceholderSpan = dart.constFn(_interceptors.JSArray$(placeholder_span.PlaceholderSpan)))(),
    InlineSpanTobool: () => (T.InlineSpanTobool = dart.constFn(dart.fnType(core.bool, [inline_span.InlineSpan])))(),
    ListOfPlaceholderDimensions: () => (T.ListOfPlaceholderDimensions = dart.constFn(core.List$(text_painter.PlaceholderDimensions)))(),
    VoidTobool: () => (T.VoidTobool = dart.constFn(dart.fnType(core.bool, [])))(),
    boolTodynamic: () => (T.boolTodynamic = dart.constFn(dart.fnType(dart.dynamic, [core.bool])))(),
    OffsetN: () => (T.OffsetN = dart.constFn(dart.nullable(ui.Offset)))(),
    BoxHitTestResultAndOffsetNTobool: () => (T.BoxHitTestResultAndOffsetNTobool = dart.constFn(dart.fnType(core.bool, [box.BoxHitTestResult, T.OffsetN()])))(),
    JSArrayOfPlaceholderDimensions: () => (T.JSArrayOfPlaceholderDimensions = dart.constFn(_interceptors.JSArray$(text_painter.PlaceholderDimensions)))(),
    JSArrayOfColor: () => (T.JSArrayOfColor = dart.constFn(_interceptors.JSArray$(ui.Color)))(),
    PaintingContextAndOffsetTovoid: () => (T.PaintingContextAndOffsetTovoid = dart.constFn(dart.fnType(dart.void, [object.PaintingContext, ui.Offset])))(),
    InlineSpanSemanticsInformationTobool: () => (T.InlineSpanSemanticsInformationTobool = dart.constFn(dart.fnType(core.bool, [inline_span.InlineSpanSemanticsInformation])))(),
    JSArrayOfSemanticsNode: () => (T.JSArrayOfSemanticsNode = dart.constFn(_interceptors.JSArray$(semantics.SemanticsNode)))(),
    ListQueueOfSemanticsNode: () => (T.ListQueueOfSemanticsNode = dart.constFn(collection.ListQueue$(semantics.SemanticsNode)))(),
    JSArrayOfDiagnosticsNode: () => (T.JSArrayOfDiagnosticsNode = dart.constFn(_interceptors.JSArray$(diagnostics.DiagnosticsNode)))(),
    EnumPropertyOfTextAlign: () => (T.EnumPropertyOfTextAlign = dart.constFn(diagnostics.EnumProperty$(ui.TextAlign)))(),
    EnumPropertyOfTextDirection: () => (T.EnumPropertyOfTextDirection = dart.constFn(diagnostics.EnumProperty$(ui.TextDirection)))(),
    EnumPropertyOfTextOverflow: () => (T.EnumPropertyOfTextOverflow = dart.constFn(diagnostics.EnumProperty$(paragraph.TextOverflow)))(),
    DiagnosticsPropertyOfLocale: () => (T.DiagnosticsPropertyOfLocale = dart.constFn(diagnostics.DiagnosticsProperty$(ui.Locale)))()
=======
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  const borders = packages__flutter__src__painting__borders$46dart.src__painting__borders;
  const assertions = packages__flutter__src__foundation__debug$46dart.src__foundation__assertions;
  const diagnostics = packages__flutter__src__foundation__debug$46dart.src__foundation__diagnostics;
  const edge_insets = packages__flutter__src__painting__edge_insets$46dart.src__painting__edge_insets;
  const object = packages__flutter__src__foundation__object$46dart.src__foundation__object;
  const border_radius = packages__flutter__src__painting__border_radius$46dart.src__painting__border_radius;
  var box_border = Object.create(dart.library);
  var $runtimeType = dartx.runtimeType;
  var $add = dartx.add;
  var $join = dartx.join;
  dart._checkModuleNullSafetyMode(true);
  var T = {
    BorderN: () => (T.BorderN = dart.constFn(dart.nullable(box_border.Border)))(),
    BorderDirectionalN: () => (T.BorderDirectionalN = dart.constFn(dart.nullable(box_border.BorderDirectional)))(),
    JSArrayOfDiagnosticsNode: () => (T.JSArrayOfDiagnosticsNode = dart.constFn(_interceptors.JSArray$(diagnostics.DiagnosticsNode)))(),
    VoidTobool: () => (T.VoidTobool = dart.constFn(dart.fnType(core.bool, [])))(),
    JSArrayOfString: () => (T.JSArrayOfString = dart.constFn(_interceptors.JSArray$(core.String)))()
>>>>>>> 75a5b68328961ba989f4b72e23f0c2c5b16d7dc4
  };
  const CT = Object.create({
    _: () => (C, CT)
  });
  dart.defineLazy(CT, {
    get C0() {
      return C[0] = dart.const({
<<<<<<< HEAD
        __proto__: paragraph.TextOverflow.prototype,
        [_name$]: "TextOverflow.clip",
=======
        __proto__: box_border.BoxShape.prototype,
        [_name$]: "BoxShape.rectangle",
>>>>>>> 75a5b68328961ba989f4b72e23f0c2c5b16d7dc4
        index: 0
      });
    },
    get C1() {
      return C[1] = dart.const({
<<<<<<< HEAD
        __proto__: paragraph.TextOverflow.prototype,
        [_name$]: "TextOverflow.fade",
=======
        __proto__: box_border.BoxShape.prototype,
        [_name$]: "BoxShape.circle",
>>>>>>> 75a5b68328961ba989f4b72e23f0c2c5b16d7dc4
        index: 1
      });
    },
    get C2() {
<<<<<<< HEAD
      return C[2] = dart.const({
        __proto__: paragraph.TextOverflow.prototype,
        [_name$]: "TextOverflow.ellipsis",
        index: 2
      });
    },
    get C3() {
      return C[3] = dart.const({
        __proto__: paragraph.TextOverflow.prototype,
        [_name$]: "TextOverflow.visible",
        index: 3
      });
    },
    get C4() {
      return C[4] = dart.constList([C[0] || CT.C0, C[1] || CT.C1, C[2] || CT.C2, C[3] || CT.C3], paragraph.TextOverflow);
    },
    get C5() {
      return C[5] = dart.const({
        __proto__: ui.TextAlign.prototype,
        [_name]: "TextAlign.start",
        index: 4
=======
      return C[2] = dart.constList([C[0] || CT.C0, C[1] || CT.C1], box_border.BoxShape);
    },
    get C4() {
      return C[4] = dart.const({
        __proto__: borders.BorderStyle.prototype,
        [_name]: "BorderStyle.none",
        index: 0
      });
    },
    get C5() {
      return C[5] = dart.const({
        __proto__: ui.Color.prototype,
        [Color_value]: 4278190080.0
      });
    },
    get C3() {
      return C[3] = dart.const({
        __proto__: borders.BorderSide.prototype,
        [BorderSide_style]: C[4] || CT.C4,
        [BorderSide_width]: 0,
        [BorderSide_color]: C[5] || CT.C5
>>>>>>> 75a5b68328961ba989f4b72e23f0c2c5b16d7dc4
      });
    },
    get C6() {
      return C[6] = dart.const({
<<<<<<< HEAD
        __proto__: text_painter.TextWidthBasis.prototype,
        [_name$0]: "TextWidthBasis.parent",
        index: 0
=======
        __proto__: borders.BorderStyle.prototype,
        [_name]: "BorderStyle.solid",
        index: 1
>>>>>>> 75a5b68328961ba989f4b72e23f0c2c5b16d7dc4
      });
    },
    get C7() {
      return C[7] = dart.const({
<<<<<<< HEAD
        __proto__: basic_types.RenderComparison.prototype,
        [_name$1]: "RenderComparison.identical",
=======
        __proto__: ui.TextDirection.prototype,
        [_name$0]: "TextDirection.rtl",
>>>>>>> 75a5b68328961ba989f4b72e23f0c2c5b16d7dc4
        index: 0
      });
    },
    get C8() {
      return C[8] = dart.const({
<<<<<<< HEAD
        __proto__: basic_types.RenderComparison.prototype,
        [_name$1]: "RenderComparison.metadata",
        index: 1
      });
    },
    get C9() {
      return C[9] = dart.const({
        __proto__: basic_types.RenderComparison.prototype,
        [_name$1]: "RenderComparison.paint",
        index: 2
      });
    },
    get C10() {
      return C[10] = dart.const({
        __proto__: basic_types.RenderComparison.prototype,
        [_name$1]: "RenderComparison.layout",
        index: 3
      });
    },
    get C11() {
      return C[11] = dart.const({
        __proto__: ui.PlaceholderAlignment.prototype,
        [_name]: "PlaceholderAlignment.baseline",
        index: 0
      });
    },
    get C12() {
      return C[12] = dart.const({
        __proto__: ui.PlaceholderAlignment.prototype,
        [_name]: "PlaceholderAlignment.aboveBaseline",
        index: 1
      });
    },
    get C13() {
      return C[13] = dart.const({
        __proto__: ui.PlaceholderAlignment.prototype,
        [_name]: "PlaceholderAlignment.belowBaseline",
        index: 2
      });
    },
    get C14() {
      return C[14] = dart.const({
        __proto__: ui.PlaceholderAlignment.prototype,
        [_name]: "PlaceholderAlignment.top",
        index: 3
      });
    },
    get C15() {
      return C[15] = dart.const({
        __proto__: ui.PlaceholderAlignment.prototype,
        [_name]: "PlaceholderAlignment.middle",
        index: 5
      });
    },
    get C16() {
      return C[16] = dart.const({
        __proto__: ui.PlaceholderAlignment.prototype,
        [_name]: "PlaceholderAlignment.bottom",
        index: 4
      });
    },
    get C17() {
      return C[17] = dart.const({
        __proto__: ui.TextDirection.prototype,
        [_name]: "TextDirection.rtl",
        index: 0
      });
    },
    get C18() {
      return C[18] = dart.const({
        __proto__: ui.TextDirection.prototype,
        [_name]: "TextDirection.ltr",
        index: 1
      });
    },
    get C19() {
      return C[19] = dart.const({
        __proto__: ui.Color.prototype,
        [Color_value]: 4294967295.0
      });
    },
    get C20() {
      return C[20] = dart.const({
        __proto__: ui.Color.prototype,
        [Color_value]: 16777215
      });
    }
  }, false);
  var C = Array(21).fill(void 0);
  var I = [
    "package:flutter/src/rendering/paragraph.dart",
    "file:///D:/DevelpmentTool/flutter/packages/flutter/lib/src/rendering/paragraph.dart"
  ];
  var _name$ = dart.privateName(paragraph, "_name");
  paragraph.TextOverflow = class TextOverflow extends core.Object {
=======
        __proto__: ui.TextDirection.prototype,
        [_name$0]: "TextDirection.ltr",
        index: 1
      });
    }
  }, false);
  var C = Array(9).fill(void 0);
  var I = [
    "package:flutter/src/painting/box_border.dart",
    "file:///D:/DevTools/flutter/packages/flutter/lib/src/painting/box_border.dart"
  ];
  var _name$ = dart.privateName(box_border, "_name");
  box_border.BoxShape = class BoxShape extends core.Object {
>>>>>>> 75a5b68328961ba989f4b72e23f0c2c5b16d7dc4
    toString() {
      return this[_name$];
    }
  };
<<<<<<< HEAD
  (paragraph.TextOverflow.new = function(index, _name) {
    this.index = index;
    this[_name$] = _name;
    ;
  }).prototype = paragraph.TextOverflow.prototype;
  dart.addTypeTests(paragraph.TextOverflow);
  dart.addTypeCaches(paragraph.TextOverflow);
  dart.setLibraryUri(paragraph.TextOverflow, I[0]);
  dart.setFieldSignature(paragraph.TextOverflow, () => ({
    __proto__: dart.getFields(paragraph.TextOverflow.__proto__),
    index: dart.finalFieldType(core.int),
    [_name$]: dart.finalFieldType(core.String)
  }));
  dart.defineExtensionMethods(paragraph.TextOverflow, ['toString']);
  paragraph.TextOverflow.clip = C[0] || CT.C0;
  paragraph.TextOverflow.fade = C[1] || CT.C1;
  paragraph.TextOverflow.ellipsis = C[2] || CT.C2;
  paragraph.TextOverflow.visible = C[3] || CT.C3;
  paragraph.TextOverflow.values = C[4] || CT.C4;
  var scale = dart.privateName(paragraph, "TextParentData.scale");
  paragraph.TextParentData = class TextParentData extends box.ContainerBoxParentData$(box.RenderBox) {
    get scale() {
      return this[scale];
    }
    set scale(value) {
      this[scale] = value;
    }
    toString() {
      let values = (() => {
        let t0 = T.JSArrayOfString().of(["offset=" + dart.str(this.offset)]);
        if (this.scale != null) t0[$add]("scale=" + dart.str(this.scale));
        t0[$add](super.toString());
        return t0;
      })();
      return values[$join]("; ");
    }
  };
  (paragraph.TextParentData.new = function() {
    this[scale] = null;
    paragraph.TextParentData.__proto__.new.call(this);
    ;
  }).prototype = paragraph.TextParentData.prototype;
  dart.addTypeTests(paragraph.TextParentData);
  dart.addTypeCaches(paragraph.TextParentData);
  dart.setLibraryUri(paragraph.TextParentData, I[0]);
  dart.setFieldSignature(paragraph.TextParentData, () => ({
    __proto__: dart.getFields(paragraph.TextParentData.__proto__),
    scale: dart.fieldType(dart.nullable(core.double))
  }));
  dart.defineExtensionMethods(paragraph.TextParentData, ['toString']);
  var index$ = dart.privateName(paragraph, "PlaceholderSpanIndexSemanticsTag.index");
  paragraph.PlaceholderSpanIndexSemanticsTag = class PlaceholderSpanIndexSemanticsTag extends semantics.SemanticsTag {
    get index() {
      return this[index$];
    }
    set index(value) {
      super.index = value;
    }
    _equals(other) {
      if (other == null) return false;
      return paragraph.PlaceholderSpanIndexSemanticsTag.is(other) && other.index === this.index;
    }
    get hashCode() {
      return ui.hashValues(dart.wrapType(paragraph.PlaceholderSpanIndexSemanticsTag), this.index);
    }
  };
  (paragraph.PlaceholderSpanIndexSemanticsTag.new = function(index) {
    this[index$] = index;
    paragraph.PlaceholderSpanIndexSemanticsTag.__proto__.new.call(this, "PlaceholderSpanIndexSemanticsTag(" + dart.str(index) + ")");
    ;
  }).prototype = paragraph.PlaceholderSpanIndexSemanticsTag.prototype;
  dart.addTypeTests(paragraph.PlaceholderSpanIndexSemanticsTag);
  dart.addTypeCaches(paragraph.PlaceholderSpanIndexSemanticsTag);
  dart.setLibraryUri(paragraph.PlaceholderSpanIndexSemanticsTag, I[0]);
  dart.setFieldSignature(paragraph.PlaceholderSpanIndexSemanticsTag, () => ({
    __proto__: dart.getFields(paragraph.PlaceholderSpanIndexSemanticsTag.__proto__),
    index: dart.finalFieldType(core.int)
  }));
  dart.defineExtensionMethods(paragraph.PlaceholderSpanIndexSemanticsTag, ['_equals']);
  dart.defineExtensionAccessors(paragraph.PlaceholderSpanIndexSemanticsTag, ['hashCode']);
  var _name = dart.privateName(ui, "_name");
  var _name$0 = dart.privateName(text_painter, "_name");
  var __RenderParagraph__placeholderSpans = dart.privateName(paragraph, "_#RenderParagraph#_placeholderSpans");
  var _needsClipping = dart.privateName(paragraph, "_needsClipping");
  var _overflowShader = dart.privateName(paragraph, "_overflowShader");
  var _placeholderDimensions = dart.privateName(paragraph, "_placeholderDimensions");
  var _semanticsInfo = dart.privateName(paragraph, "_semanticsInfo");
  var _cachedChildNodes = dart.privateName(paragraph, "_cachedChildNodes");
  var _softWrap = dart.privateName(paragraph, "_softWrap");
  var _overflow = dart.privateName(paragraph, "_overflow");
  var _textPainter = dart.privateName(paragraph, "_textPainter");
  var _extractPlaceholderSpans = dart.privateName(paragraph, "_extractPlaceholderSpans");
  var _name$1 = dart.privateName(basic_types, "_name");
  var _placeholderSpans = dart.privateName(paragraph, "_placeholderSpans");
  var _canComputeIntrinsics = dart.privateName(paragraph, "_canComputeIntrinsics");
  var _computeChildrenWidthWithMinIntrinsics = dart.privateName(paragraph, "_computeChildrenWidthWithMinIntrinsics");
  var _layoutText = dart.privateName(paragraph, "_layoutText");
  var _computeChildrenWidthWithMaxIntrinsics = dart.privateName(paragraph, "_computeChildrenWidthWithMaxIntrinsics");
  var _computeChildrenHeightWithMinIntrinsics = dart.privateName(paragraph, "_computeChildrenHeightWithMinIntrinsics");
  var _computeIntrinsicHeight = dart.privateName(paragraph, "_computeIntrinsicHeight");
  var _layoutTextWithConstraints = dart.privateName(paragraph, "_layoutTextWithConstraints");
  var _layoutChildren = dart.privateName(paragraph, "_layoutChildren");
  var _setParentData = dart.privateName(paragraph, "_setParentData");
  var _canComputeDryLayout = dart.privateName(paragraph, "_canComputeDryLayout");
  var Color_value = dart.privateName(ui, "Color.value");
  const RenderBox_ContainerRenderObjectMixin$36 = class RenderBox_ContainerRenderObjectMixin extends box.RenderBox {};
  (RenderBox_ContainerRenderObjectMixin$36.new = function() {
    object.ContainerRenderObjectMixin$(box.RenderBox, paragraph.TextParentData)[dart.mixinNew].call(this);
    RenderBox_ContainerRenderObjectMixin$36.__proto__.new.call(this);
  }).prototype = RenderBox_ContainerRenderObjectMixin$36.prototype;
  dart.applyMixin(RenderBox_ContainerRenderObjectMixin$36, object.ContainerRenderObjectMixin$(box.RenderBox, paragraph.TextParentData));
  const RenderBox_RenderBoxContainerDefaultsMixin$36 = class RenderBox_RenderBoxContainerDefaultsMixin extends RenderBox_ContainerRenderObjectMixin$36 {};
  (RenderBox_RenderBoxContainerDefaultsMixin$36.new = function() {
    RenderBox_RenderBoxContainerDefaultsMixin$36.__proto__.new.call(this);
  }).prototype = RenderBox_RenderBoxContainerDefaultsMixin$36.prototype;
  dart.applyMixin(RenderBox_RenderBoxContainerDefaultsMixin$36, box.RenderBoxContainerDefaultsMixin$(box.RenderBox, paragraph.TextParentData));
  const RenderBox_RelayoutWhenSystemFontsChangeMixin$36 = class RenderBox_RelayoutWhenSystemFontsChangeMixin extends RenderBox_RenderBoxContainerDefaultsMixin$36 {};
  (RenderBox_RelayoutWhenSystemFontsChangeMixin$36.new = function() {
    RenderBox_RelayoutWhenSystemFontsChangeMixin$36.__proto__.new.call(this);
  }).prototype = RenderBox_RelayoutWhenSystemFontsChangeMixin$36.prototype;
  dart.applyMixin(RenderBox_RelayoutWhenSystemFontsChangeMixin$36, object.RelayoutWhenSystemFontsChangeMixin);
  paragraph.RenderParagraph = class RenderParagraph extends RenderBox_RelayoutWhenSystemFontsChangeMixin$36 {
    setupParentData(child) {
      box.RenderBox.as(child);
      if (!paragraph.TextParentData.is(child.parentData)) child.parentData = new paragraph.TextParentData.new();
    }
    get text() {
      return dart.nullCheck(this[_textPainter].text);
    }
    set text(value) {
      if (!(value !== null)) dart.assertFailed(null, I[1], 143, 12, "value != null");
      switch (dart.nullCheck(this[_textPainter].text).compareTo(value)) {
        case C[7] || CT.C7:
        case C[8] || CT.C8:
        {
          return;
        }
        case C[9] || CT.C9:
        {
          this[_textPainter].text = value;
          this[_extractPlaceholderSpans](value);
          this.markNeedsPaint();
          this.markNeedsSemanticsUpdate();
          break;
        }
        case C[10] || CT.C10:
        {
          this[_textPainter].text = value;
          this[_overflowShader] = null;
          this[_extractPlaceholderSpans](value);
          this.markNeedsLayout();
          break;
        }
      }
    }
    get [_placeholderSpans]() {
      let t1;
      t1 = this[__RenderParagraph__placeholderSpans];
      return t1 == null ? dart.throw(new _internal.LateError.fieldNI("_placeholderSpans")) : t1;
    }
    set [_placeholderSpans](t1) {
      this[__RenderParagraph__placeholderSpans] = t1;
    }
    [_extractPlaceholderSpans](span) {
      this[_placeholderSpans] = T.JSArrayOfPlaceholderSpan().of([]);
      span.visitChildren(dart.fn(span => {
        if (placeholder_span.PlaceholderSpan.is(span)) {
          this[_placeholderSpans][$add](span);
        }
        return true;
      }, T.InlineSpanTobool()));
    }
    get textAlign() {
      return this[_textPainter].textAlign;
    }
    set textAlign(value) {
      if (!(value !== null)) dart.assertFailed(null, I[1], 177, 12, "value != null");
      if (this[_textPainter].textAlign === value) return;
      this[_textPainter].textAlign = value;
      this.markNeedsPaint();
    }
    get textDirection() {
      return dart.nullCheck(this[_textPainter].textDirection);
    }
    set textDirection(value) {
      if (!(value !== null)) dart.assertFailed(null, I[1], 199, 12, "value != null");
      if (this[_textPainter].textDirection === value) return;
      this[_textPainter].textDirection = value;
      this.markNeedsLayout();
    }
    get softWrap() {
      return this[_softWrap];
    }
    set softWrap(value) {
      if (!(value !== null)) dart.assertFailed(null, I[1], 216, 12, "value != null");
      if (this[_softWrap] === value) return;
      this[_softWrap] = value;
      this.markNeedsLayout();
    }
    get overflow() {
      return this[_overflow];
    }
    set overflow(value) {
      if (!(value !== null)) dart.assertFailed(null, I[1], 227, 12, "value != null");
      if (this[_overflow] === value) return;
      this[_overflow] = value;
      this[_textPainter].ellipsis = value === paragraph.TextOverflow.ellipsis ? "…" : null;
      this.markNeedsLayout();
    }
    get textScaleFactor() {
      return this[_textPainter].textScaleFactor;
    }
    set textScaleFactor(value) {
      if (!(value !== null)) dart.assertFailed(null, I[1], 241, 12, "value != null");
      if (this[_textPainter].textScaleFactor === value) return;
      this[_textPainter].textScaleFactor = value;
      this[_overflowShader] = null;
      this.markNeedsLayout();
    }
    get maxLines() {
      return this[_textPainter].maxLines;
    }
    set maxLines(value) {
      if (!(value == null || dart.notNull(value) > 0)) dart.assertFailed(null, I[1], 256, 12, "value == null || value > 0");
      if (this[_textPainter].maxLines == value) return;
      this[_textPainter].maxLines = value;
      this[_overflowShader] = null;
      this.markNeedsLayout();
    }
    get locale() {
      return this[_textPainter].locale;
    }
    set locale(value) {
      if (dart.equals(this[_textPainter].locale, value)) return;
      this[_textPainter].locale = value;
      this[_overflowShader] = null;
      this.markNeedsLayout();
    }
    get strutStyle() {
      return this[_textPainter].strutStyle;
    }
    set strutStyle(value) {
      if (dart.equals(this[_textPainter].strutStyle, value)) return;
      this[_textPainter].strutStyle = value;
      this[_overflowShader] = null;
      this.markNeedsLayout();
    }
    get textWidthBasis() {
      return this[_textPainter].textWidthBasis;
    }
    set textWidthBasis(value) {
      if (!(value !== null)) dart.assertFailed(null, I[1], 295, 12, "value != null");
      if (this[_textPainter].textWidthBasis === value) return;
      this[_textPainter].textWidthBasis = value;
      this[_overflowShader] = null;
      this.markNeedsLayout();
    }
    get textHeightBehavior() {
      return this[_textPainter].textHeightBehavior;
    }
    set textHeightBehavior(value) {
      if (dart.equals(this[_textPainter].textHeightBehavior, value)) return;
      this[_textPainter].textHeightBehavior = value;
      this[_overflowShader] = null;
      this.markNeedsLayout();
    }
    computeMinIntrinsicWidth(height) {
      if (!this[_canComputeIntrinsics]()) {
        return 0.0;
      }
      this[_computeChildrenWidthWithMinIntrinsics](height);
      this[_layoutText]();
      return this[_textPainter].minIntrinsicWidth;
    }
    computeMaxIntrinsicWidth(height) {
      if (!this[_canComputeIntrinsics]()) {
        return 0.0;
      }
      this[_computeChildrenWidthWithMaxIntrinsics](height);
      this[_layoutText]();
      return this[_textPainter].maxIntrinsicWidth;
    }
    [_computeIntrinsicHeight](width) {
      if (!this[_canComputeIntrinsics]()) {
        return 0.0;
      }
      this[_computeChildrenHeightWithMinIntrinsics](width);
      this[_layoutText]({minWidth: width, maxWidth: width});
      return this[_textPainter].height;
    }
    computeMinIntrinsicHeight(width) {
      return this[_computeIntrinsicHeight](width);
    }
    computeMaxIntrinsicHeight(width) {
      return this[_computeIntrinsicHeight](width);
    }
    computeDistanceToActualBaseline(baseline) {
      if (!!this.debugNeedsLayout) dart.assertFailed(null, I[1], 354, 12, "!debugNeedsLayout");
      if (!(this.constraints !== null)) dart.assertFailed(null, I[1], 355, 12, "constraints != null");
      if (!this.constraints.debugAssertIsValid()) dart.assertFailed(null, I[1], 356, 12, "constraints.debugAssertIsValid()");
      this[_layoutTextWithConstraints](this.constraints);
      return this[_textPainter].computeDistanceToActualBaseline(ui.TextBaseline.alphabetic);
    }
    [_canComputeIntrinsics]() {
      for (let span of this[_placeholderSpans]) {
        switch (span.alignment) {
          case C[11] || CT.C11:
          case C[12] || CT.C12:
          case C[13] || CT.C13:
          {
            {
              if (!object.RenderObject.debugCheckingIntrinsics) dart.assertFailed("Intrinsics are not available for PlaceholderAlignment.baseline, " + "PlaceholderAlignment.aboveBaseline, or PlaceholderAlignment.belowBaseline.", I[1], 377, 13, "RenderObject.debugCheckingIntrinsics");
              return false;
            }
          }
          case C[14] || CT.C14:
          case C[15] || CT.C15:
          case C[16] || CT.C16:
          {
            {
              continue;
            }
          }
        }
      }
      return true;
    }
    [_computeChildrenWidthWithMaxIntrinsics](height) {
      let child = this.firstChild;
      let placeholderDimensions = T.ListOfPlaceholderDimensions().filled(this.childCount, text_painter.PlaceholderDimensions.empty, {growable: false});
      let childIndex = 0;
      while (child != null) {
        placeholderDimensions[$_set](childIndex, new text_painter.PlaceholderDimensions.new({size: new ui.Size.new(child.getMaxIntrinsicWidth(1 / 0), 0.0), alignment: this[_placeholderSpans][$_get](childIndex).alignment, baseline: this[_placeholderSpans][$_get](childIndex).baseline}));
        child = this.childAfter(child);
        childIndex = childIndex + 1;
      }
      this[_textPainter].setPlaceholderDimensions(placeholderDimensions);
    }
    [_computeChildrenWidthWithMinIntrinsics](height) {
      let child = this.firstChild;
      let placeholderDimensions = T.ListOfPlaceholderDimensions().filled(this.childCount, text_painter.PlaceholderDimensions.empty, {growable: false});
      let childIndex = 0;
      while (child != null) {
        placeholderDimensions[$_set](childIndex, new text_painter.PlaceholderDimensions.new({size: new ui.Size.new(child.getMinIntrinsicWidth(1 / 0), 0.0), alignment: this[_placeholderSpans][$_get](childIndex).alignment, baseline: this[_placeholderSpans][$_get](childIndex).baseline}));
        child = this.childAfter(child);
        childIndex = childIndex + 1;
      }
      this[_textPainter].setPlaceholderDimensions(placeholderDimensions);
    }
    [_computeChildrenHeightWithMinIntrinsics](width) {
      let child = this.firstChild;
      let placeholderDimensions = T.ListOfPlaceholderDimensions().filled(this.childCount, text_painter.PlaceholderDimensions.empty, {growable: false});
      let childIndex = 0;
      width = width / this.textScaleFactor;
      while (child != null) {
        let size = child.getDryLayout(new box.BoxConstraints.new({maxWidth: width}));
        placeholderDimensions[$_set](childIndex, new text_painter.PlaceholderDimensions.new({size: size, alignment: this[_placeholderSpans][$_get](childIndex).alignment, baseline: this[_placeholderSpans][$_get](childIndex).baseline}));
        child = this.childAfter(child);
        childIndex = childIndex + 1;
      }
      this[_textPainter].setPlaceholderDimensions(placeholderDimensions);
    }
    hitTestSelf(position) {
      return true;
    }
    hitTestChildren(result, opts) {
      let t6;
      let position = opts && 'position' in opts ? opts.position : null;
      let hitText = null;
      function hitText$35get() {
        let t3;
        t3 = hitText;
        return t3 == null ? dart.throw(new _internal.LateError.localNI("hitText")) : t3;
      }
      dart.fn(hitText$35get, T.VoidTobool());
      function hitText$35set(t4) {
        if (hitText == null)
          return hitText = t4;
        else
          dart.throw(new _internal.LateError.localAI("hitText"));
      }
      dart.fn(hitText$35set, T.boolTodynamic());
      let textPosition = this[_textPainter].getPositionForOffset(position);
      let span = dart.nullCheck(this[_textPainter].text).getSpanForPosition(textPosition);
      if (span != null && hit_test.HitTestTarget.is(span)) {
        result.add(new hit_test.HitTestEntry.new(hit_test.HitTestTarget.as(span)));
        hitText$35set(true);
      } else {
        hitText$35set(false);
      }
      let child = this.firstChild;
      let childIndex = 0;
      while (child != null && childIndex < dart.nullCheck(this[_textPainter].inlinePlaceholderBoxes)[$length]) {
        let textParentData = paragraph.TextParentData.as(dart.nullCheck(child.parentData));
        let transform = (t6 = vector_math_64.Matrix4.translationValues(textParentData.offset.dx, textParentData.offset.dy, 0.0), (() => {
          t6.scale(textParentData.scale, textParentData.scale, textParentData.scale);
          return t6;
        })());
        let isHit = result.addWithPaintTransform({transform: transform, position: position, hitTest: dart.fn((result, transformed) => {
            if (!dart.fn(() => {
              let manualPosition = position['-'](textParentData.offset)['/'](dart.nullCheck(textParentData.scale));
              return (dart.nullCheck(transformed).dx - manualPosition.dx)[$abs]() < 1e-10 && (transformed.dy - manualPosition.dy)[$abs]() < 1e-10;
            }, T.VoidTobool())()) dart.assertFailed(null, I[1], 483, 18, "() {\r\n            final Offset manualPosition = (position - textParentData.offset) / textParentData.scale!;\r\n            return (transformed!.dx - manualPosition.dx).abs() < precisionErrorTolerance\r\n              && (transformed.dy - manualPosition.dy).abs() < precisionErrorTolerance;\r\n          }()");
            return dart.nullCheck(child).hitTest(result, {position: dart.nullCheck(transformed)});
          }, T.BoxHitTestResultAndOffsetNTobool())});
        if (isHit) {
          return true;
        }
        child = this.childAfter(child);
        childIndex = childIndex + 1;
      }
      return hitText$35get();
    }
    get debugHasOverflowShader() {
      return this[_overflowShader] != null;
    }
    [_layoutText](opts) {
      let minWidth = opts && 'minWidth' in opts ? opts.minWidth : 0;
      let maxWidth = opts && 'maxWidth' in opts ? opts.maxWidth : 1 / 0;
      let widthMatters = this.softWrap || this.overflow === paragraph.TextOverflow.ellipsis;
      this[_textPainter].layout({minWidth: minWidth, maxWidth: widthMatters ? maxWidth : 1 / 0});
    }
    systemFontsDidChange() {
      super.systemFontsDidChange();
      this[_textPainter].markNeedsLayout();
    }
    [_layoutTextWithConstraints](constraints) {
      this[_textPainter].setPlaceholderDimensions(this[_placeholderDimensions]);
      this[_layoutText]({minWidth: constraints.minWidth, maxWidth: constraints.maxWidth});
    }
    [_layoutChildren](constraints, opts) {
      let dry = opts && 'dry' in opts ? opts.dry : false;
      if (this.childCount === 0) {
        return T.JSArrayOfPlaceholderDimensions().of([]);
      }
      let child = this.firstChild;
      let placeholderDimensions = T.ListOfPlaceholderDimensions().filled(this.childCount, text_painter.PlaceholderDimensions.empty, {growable: false});
      let childIndex = 0;
      let boxConstraints = new box.BoxConstraints.new({maxWidth: constraints.maxWidth});
      boxConstraints = boxConstraints['/'](this.textScaleFactor);
      while (child != null) {
        let baselineOffset = null;
        let childSize = null;
        if (!dry) {
          child.layout(boxConstraints, {parentUsesSize: true});
          childSize = child.size;
          switch (this[_placeholderSpans][$_get](childIndex).alignment) {
            case C[11] || CT.C11:
            {
              {
                baselineOffset = child.getDistanceToBaseline(dart.nullCheck(this[_placeholderSpans][$_get](childIndex).baseline));
                break;
              }
            }
            default:
            {
              {
                baselineOffset = null;
                break;
              }
            }
          }
        } else {
          if (!(this[_placeholderSpans][$_get](childIndex).alignment !== ui.PlaceholderAlignment.baseline)) dart.assertFailed(null, I[1], 578, 16, "_placeholderSpans[childIndex].alignment != ui.PlaceholderAlignment.baseline");
          childSize = child.getDryLayout(boxConstraints);
        }
        placeholderDimensions[$_set](childIndex, new text_painter.PlaceholderDimensions.new({size: childSize, alignment: this[_placeholderSpans][$_get](childIndex).alignment, baseline: this[_placeholderSpans][$_get](childIndex).baseline, baselineOffset: baselineOffset}));
        child = this.childAfter(child);
        childIndex = childIndex + 1;
      }
      return placeholderDimensions;
    }
    [_setParentData]() {
      let child = this.firstChild;
      let childIndex = 0;
      while (child != null && childIndex < dart.nullCheck(this[_textPainter].inlinePlaceholderBoxes)[$length]) {
        let textParentData = paragraph.TextParentData.as(dart.nullCheck(child.parentData));
        textParentData.offset = new ui.Offset.new(dart.nullCheck(this[_textPainter].inlinePlaceholderBoxes)[$_get](childIndex).left, dart.nullCheck(this[_textPainter].inlinePlaceholderBoxes)[$_get](childIndex).top);
        textParentData.scale = dart.nullCheck(this[_textPainter].inlinePlaceholderScales)[$_get](childIndex);
        child = this.childAfter(child);
        childIndex = childIndex + 1;
      }
    }
    [_canComputeDryLayout]() {
      for (let span of this[_placeholderSpans]) {
        switch (span.alignment) {
          case C[11] || CT.C11:
          case C[12] || CT.C12:
          case C[13] || CT.C13:
          {
            {
              return false;
            }
          }
          case C[14] || CT.C14:
          case C[15] || CT.C15:
          case C[16] || CT.C16:
          {
            {
              continue;
            }
          }
        }
      }
      return true;
    }
    computeDryLayout(constraints) {
      if (!this[_canComputeDryLayout]()) {
        if (!this.debugCannotComputeDryLayout({reason: "Dry layout not available for alignments that require baseline."})) dart.assertFailed(null, I[1], 634, 14, "debugCannotComputeDryLayout(\r\n        reason: 'Dry layout not available for alignments that require baseline.',\r\n      )");
        return ui.Size.zero;
      }
      this[_textPainter].setPlaceholderDimensions(this[_layoutChildren](constraints, {dry: true}));
      this[_layoutText]({minWidth: constraints.minWidth, maxWidth: constraints.maxWidth});
      return constraints.constrain(this[_textPainter].size);
    }
    performLayout() {
      let t6;
      let constraints = this.constraints;
      this[_placeholderDimensions] = this[_layoutChildren](constraints);
      this[_layoutTextWithConstraints](constraints);
      this[_setParentData]();
      let textSize = this[_textPainter].size;
      let textDidExceedMaxLines = this[_textPainter].didExceedMaxLines;
      this.size = constraints.constrain(textSize);
      let didOverflowHeight = this.size.height < textSize.height || textDidExceedMaxLines;
      let didOverflowWidth = this.size.width < textSize.width;
      let hasVisualOverflow = didOverflowWidth || didOverflowHeight;
      if (hasVisualOverflow) {
        switch (this[_overflow]) {
          case C[3] || CT.C3:
          {
            this[_needsClipping] = false;
            this[_overflowShader] = null;
            break;
          }
          case C[0] || CT.C0:
          case C[2] || CT.C2:
          {
            this[_needsClipping] = true;
            this[_overflowShader] = null;
            break;
          }
          case C[1] || CT.C1:
          {
            if (!(this.textDirection !== null)) dart.assertFailed(null, I[1], 680, 18, "textDirection != null");
            this[_needsClipping] = true;
            let fadeSizePainter = (t6 = new text_painter.TextPainter.new({text: new text_span.TextSpan.new({style: dart.nullCheck(this[_textPainter].text).style, text: "…"}), textDirection: this.textDirection, textScaleFactor: this.textScaleFactor, locale: this.locale}), (() => {
              t6.layout();
              return t6;
            })());
            if (didOverflowWidth) {
              let fadeEnd = null;
              let fadeStart = null;
              switch (this.textDirection) {
                case C[17] || CT.C17:
                {
                  fadeEnd = 0.0;
                  fadeStart = fadeSizePainter.width;
                  break;
                }
                case C[18] || CT.C18:
                {
                  fadeEnd = this.size.width;
                  fadeStart = fadeEnd - fadeSizePainter.width;
                  break;
                }
              }
              this[_overflowShader] = ui.Gradient.linear(new ui.Offset.new(fadeStart, 0.0), new ui.Offset.new(fadeEnd, 0.0), T.JSArrayOfColor().of([C[19] || CT.C19, C[20] || CT.C20]));
            } else {
              let fadeEnd = this.size.height;
              let fadeStart = fadeEnd - fadeSizePainter.height / 2.0;
              this[_overflowShader] = ui.Gradient.linear(new ui.Offset.new(0.0, fadeStart), new ui.Offset.new(0.0, fadeEnd), T.JSArrayOfColor().of([C[19] || CT.C19, C[20] || CT.C20]));
            }
            break;
          }
        }
      } else {
        this[_needsClipping] = false;
        this[_overflowShader] = null;
      }
    }
    paint(context, offset) {
      let t6;
      this[_layoutTextWithConstraints](this.constraints);
      if (!dart.fn(() => {
        let t6;
        if (debug.debugRepaintTextRainbowEnabled) {
          let paint = (t6 = ui.Paint.new(), (() => {
            t6.color = debug.debugCurrentRepaintColor.toColor();
            return t6;
          })());
          context.canvas.drawRect(offset['&'](this.size), paint);
        }
        return true;
      }, T.VoidTobool())()) dart.assertFailed(null, I[1], 736, 12, "() {\r\n      if (debugRepaintTextRainbowEnabled) {\r\n        final Paint paint = Paint()\r\n          ..color = debugCurrentRepaintColor.toColor();\r\n        context.canvas.drawRect(offset & size, paint);\r\n      }\r\n      return true;\r\n    }()");
      if (this[_needsClipping]) {
        let bounds = offset['&'](this.size);
        if (this[_overflowShader] != null) {
          context.canvas.saveLayer(bounds, ui.Paint.new());
        } else {
          context.canvas.save();
        }
        context.canvas.clipRect(bounds);
      }
      this[_textPainter].paint(context.canvas, offset);
      let child = this.firstChild;
      let childIndex = 0;
      while (child != null && childIndex < dart.nullCheck(this[_textPainter].inlinePlaceholderBoxes)[$length]) {
        let textParentData = paragraph.TextParentData.as(dart.nullCheck(child.parentData));
        let scale = dart.nullCheck(textParentData.scale);
        context.pushTransform(this.needsCompositing, offset['+'](textParentData.offset), vector_math_64.Matrix4.diagonal3Values(scale, scale, scale), dart.fn((context, offset) => {
          context.paintChild(dart.nullCheck(child), offset);
        }, T.PaintingContextAndOffsetTovoid()));
        child = this.childAfter(child);
        childIndex = childIndex + 1;
      }
      if (this[_needsClipping]) {
        if (this[_overflowShader] != null) {
          context.canvas.translate(offset.dx, offset.dy);
          let paint = (t6 = ui.Paint.new(), (() => {
            t6.blendMode = ui.BlendMode.modulate;
            t6.shader = this[_overflowShader];
            return t6;
          })());
          context.canvas.drawRect(ui.Offset.zero['&'](this.size), paint);
        }
        context.canvas.restore();
      }
    }
    getOffsetForCaret(position, caretPrototype) {
      if (!!this.debugNeedsLayout) dart.assertFailed(null, I[1], 798, 12, "!debugNeedsLayout");
      this[_layoutTextWithConstraints](this.constraints);
      return this[_textPainter].getOffsetForCaret(position, caretPrototype);
    }
    getFullHeightForCaret(position) {
      if (!!this.debugNeedsLayout) dart.assertFailed(null, I[1], 807, 12, "!debugNeedsLayout");
      this[_layoutTextWithConstraints](this.constraints);
      return this[_textPainter].getFullHeightForCaret(position, ui.Rect.zero);
    }
    getBoxesForSelection(selection) {
      if (!!this.debugNeedsLayout) dart.assertFailed(null, I[1], 820, 12, "!debugNeedsLayout");
      this[_layoutTextWithConstraints](this.constraints);
      return this[_textPainter].getBoxesForSelection(selection);
    }
    getPositionForOffset(offset) {
      if (!!this.debugNeedsLayout) dart.assertFailed(null, I[1], 829, 12, "!debugNeedsLayout");
      this[_layoutTextWithConstraints](this.constraints);
      return this[_textPainter].getPositionForOffset(offset);
    }
    getWordBoundary(position) {
      if (!!this.debugNeedsLayout) dart.assertFailed(null, I[1], 844, 12, "!debugNeedsLayout");
      this[_layoutTextWithConstraints](this.constraints);
      return this[_textPainter].getWordBoundary(position);
    }
    get textSize() {
      if (!!this.debugNeedsLayout) dart.assertFailed(null, I[1], 859, 12, "!debugNeedsLayout");
      return this[_textPainter].size;
    }
    describeSemanticsConfiguration(config) {
      let t6;
      super.describeSemanticsConfiguration(config);
      this[_semanticsInfo] = this.text.getSemanticsInformation();
      if (dart.nullCheck(this[_semanticsInfo])[$any](dart.fn(info => info.recognizer != null, T.InlineSpanSemanticsInformationTobool()))) {
        config.explicitChildNodes = true;
        config.isSemanticBoundary = true;
      } else {
        let buffer = new core.StringBuffer.new();
        for (let info of dart.nullCheck(this[_semanticsInfo])) {
          buffer.write((t6 = info.semanticsLabel, t6 == null ? info.text : t6));
        }
        config.label = buffer.toString();
        config.textDirection = this.textDirection;
      }
    }
    assembleSemanticsNode(node, config, children) {
      let t7, t7$, t6, t6$, t6$0;
      if (!(this[_semanticsInfo] != null && dart.nullCheck(this[_semanticsInfo])[$isNotEmpty])) dart.assertFailed(null, I[1], 893, 12, "_semanticsInfo != null && _semanticsInfo!.isNotEmpty");
      let newChildren = T.JSArrayOfSemanticsNode().of([]);
      let currentDirection = this.textDirection;
      let currentRect = null;
      let ordinal = 0.0;
      let start = 0;
      let placeholderIndex = 0;
      let childIndex = 0;
      let child = this.firstChild;
      let newChildCache = new (T.ListQueueOfSemanticsNode()).new();
      for (let info of inline_span.combineSemanticsInfo(dart.nullCheck(this[_semanticsInfo]))) {
        let selection = new text_editing.TextSelection.new({baseOffset: start, extentOffset: start + info.text.length});
        start = start + info.text.length;
        if (info.isPlaceholder) {
          while (children[$length] > childIndex && children[$elementAt](childIndex).isTagged(new paragraph.PlaceholderSpanIndexSemanticsTag.new(placeholderIndex))) {
            let childNode = children[$elementAt](childIndex);
            let parentData = paragraph.TextParentData.as(dart.nullCheck(dart.nullCheck(child).parentData));
            childNode.rect = new ui.Rect.fromLTWH(childNode.rect.left, childNode.rect.top, childNode.rect.width * dart.nullCheck(parentData.scale), childNode.rect.height * dart.nullCheck(parentData.scale));
            newChildren[$add](childNode);
            childIndex = childIndex + 1;
          }
          child = this.childAfter(dart.nullCheck(child));
          placeholderIndex = placeholderIndex + 1;
        } else {
          let initialDirection = currentDirection;
          let rects = this.getBoxesForSelection(selection);
          if (rects[$isEmpty]) {
            continue;
          }
          let rect = rects[$first].toRect();
          currentDirection = rects[$first].direction;
          for (let textBox of rects[$skip](1)) {
            rect = rect.expandToInclude(textBox.toRect());
            currentDirection = textBox.direction;
          }
          rect = new ui.Rect.fromLTWH(math.max(core.double, 0.0, rect.left), math.max(core.double, 0.0, rect.top), math.min(core.double, rect.width, this.constraints.maxWidth), math.min(core.double, rect.height, this.constraints.maxHeight));
          currentRect = new ui.Rect.fromLTRB(rect.left[$floorToDouble]() - 4.0, rect.top[$floorToDouble]() - 4.0, rect.right[$ceilToDouble]() + 4.0, rect.bottom[$ceilToDouble]() + 4.0);
          let configuration = (t6 = new semantics.SemanticsConfiguration.new(), (() => {
            t6.sortKey = new semantics.OrdinalSortKey.new((t7 = ordinal, ordinal = t7 + 1, t7));
            t6.textDirection = initialDirection;
            t6.label = (t7$ = info.semanticsLabel, t7$ == null ? info.text : t7$);
            return t6;
          })());
          let recognizer = info.recognizer;
          if (recognizer != null) {
            if (tap.TapGestureRecognizer.is(recognizer)) {
              if (recognizer.onTap != null) {
                configuration.onTap = recognizer.onTap;
                configuration.isLink = true;
              }
            } else if (multitap.DoubleTapGestureRecognizer.is(recognizer)) {
              if (recognizer.onDoubleTap != null) {
                configuration.onTap = recognizer.onDoubleTap;
                configuration.isLink = true;
              }
            } else if (long_press.LongPressGestureRecognizer.is(recognizer)) {
              if (recognizer.onLongPress != null) {
                configuration.onLongPress = recognizer.onLongPress;
              }
            } else {
              if (!false) dart.assertFailed(dart.str(dart.runtimeType(recognizer)) + " is not supported.", I[1], 977, 20, "false");
            }
          }
          let newChild = (t6$ = this[_cachedChildNodes], t6$ == null ? null : t6$[$isNotEmpty]) === true ? dart.nullCheck(this[_cachedChildNodes]).removeFirst() : new semantics.SemanticsNode.new();
          t6$0 = newChild;
          (() => {
            t6$0.updateWith({config: configuration});
            t6$0.rect = currentRect;
            return t6$0;
          })();
          newChildCache.addLast(newChild);
          newChildren[$add](newChild);
        }
      }
      if (!(childIndex === children[$length])) dart.assertFailed(null, I[1], 991, 12, "childIndex == children.length");
      if (!(child == null)) dart.assertFailed(null, I[1], 992, 12, "child == null");
      this[_cachedChildNodes] = newChildCache;
      node.updateWith({config: config, childrenInInversePaintOrder: newChildren});
    }
    clearSemantics() {
      super.clearSemantics();
      this[_cachedChildNodes] = null;
    }
    debugDescribeChildren() {
      return T.JSArrayOfDiagnosticsNode().of([this.text.toDiagnosticsNode({name: "text", style: diagnostics.DiagnosticsTreeStyle.transition})]);
    }
    debugFillProperties(properties) {
      super.debugFillProperties(properties);
      properties.add(new (T.EnumPropertyOfTextAlign()).new("textAlign", this.textAlign));
      properties.add(new (T.EnumPropertyOfTextDirection()).new("textDirection", this.textDirection));
      properties.add(new diagnostics.FlagProperty.new("softWrap", {value: this.softWrap, ifTrue: "wrapping at box width", ifFalse: "no wrapping except at line break characters", showName: true}));
      properties.add(new (T.EnumPropertyOfTextOverflow()).new("overflow", this.overflow));
      properties.add(new diagnostics.DoubleProperty.new("textScaleFactor", this.textScaleFactor, {defaultValue: 1.0}));
      properties.add(new (T.DiagnosticsPropertyOfLocale()).new("locale", this.locale, {defaultValue: null}));
      properties.add(new diagnostics.IntProperty.new("maxLines", this.maxLines, {ifNull: "unlimited"}));
    }
  };
  (paragraph.RenderParagraph.new = function(text, opts) {
    let textAlign = opts && 'textAlign' in opts ? opts.textAlign : C[5] || CT.C5;
    let textDirection = opts && 'textDirection' in opts ? opts.textDirection : null;
    let softWrap = opts && 'softWrap' in opts ? opts.softWrap : true;
    let overflow = opts && 'overflow' in opts ? opts.overflow : C[0] || CT.C0;
    let textScaleFactor = opts && 'textScaleFactor' in opts ? opts.textScaleFactor : 1;
    let maxLines = opts && 'maxLines' in opts ? opts.maxLines : null;
    let locale = opts && 'locale' in opts ? opts.locale : null;
    let strutStyle = opts && 'strutStyle' in opts ? opts.strutStyle : null;
    let textWidthBasis = opts && 'textWidthBasis' in opts ? opts.textWidthBasis : C[6] || CT.C6;
    let textHeightBehavior = opts && 'textHeightBehavior' in opts ? opts.textHeightBehavior : null;
    let children = opts && 'children' in opts ? opts.children : null;
    this[__RenderParagraph__placeholderSpans] = null;
    this[_needsClipping] = false;
    this[_overflowShader] = null;
    this[_placeholderDimensions] = null;
    this[_semanticsInfo] = null;
    this[_cachedChildNodes] = null;
    if (!(text !== null)) dart.assertFailed(null, I[1], 105, 15, "text != null");
    if (!text.debugAssertIsValid()) dart.assertFailed(null, I[1], 106, 15, "text.debugAssertIsValid()");
    if (!(textAlign !== null)) dart.assertFailed(null, I[1], 107, 15, "textAlign != null");
    if (!(textDirection !== null)) dart.assertFailed(null, I[1], 108, 15, "textDirection != null");
    if (!(softWrap !== null)) dart.assertFailed(null, I[1], 109, 15, "softWrap != null");
    if (!(overflow !== null)) dart.assertFailed(null, I[1], 110, 15, "overflow != null");
    if (!(textScaleFactor !== null)) dart.assertFailed(null, I[1], 111, 15, "textScaleFactor != null");
    if (!(maxLines == null || dart.notNull(maxLines) > 0)) dart.assertFailed(null, I[1], 112, 15, "maxLines == null || maxLines > 0");
    if (!(textWidthBasis !== null)) dart.assertFailed(null, I[1], 113, 15, "textWidthBasis != null");
    this[_softWrap] = softWrap;
    this[_overflow] = overflow;
    this[_textPainter] = new text_painter.TextPainter.new({text: text, textAlign: textAlign, textDirection: textDirection, textScaleFactor: textScaleFactor, maxLines: maxLines, ellipsis: overflow === paragraph.TextOverflow.ellipsis ? "…" : null, locale: locale, strutStyle: strutStyle, textWidthBasis: textWidthBasis, textHeightBehavior: textHeightBehavior});
    paragraph.RenderParagraph.__proto__.new.call(this);
    this.addAll(children);
    this[_extractPlaceholderSpans](text);
  }).prototype = paragraph.RenderParagraph.prototype;
  dart.addTypeTests(paragraph.RenderParagraph);
  dart.addTypeCaches(paragraph.RenderParagraph);
  dart.setMethodSignature(paragraph.RenderParagraph, () => ({
    __proto__: dart.getMethods(paragraph.RenderParagraph.__proto__),
    [_extractPlaceholderSpans]: dart.fnType(dart.void, [inline_span.InlineSpan]),
    [_computeIntrinsicHeight]: dart.fnType(core.double, [core.double]),
    computeDistanceToActualBaseline: dart.fnType(core.double, [ui.TextBaseline]),
    [_canComputeIntrinsics]: dart.fnType(core.bool, []),
    [_computeChildrenWidthWithMaxIntrinsics]: dart.fnType(dart.void, [core.double]),
    [_computeChildrenWidthWithMinIntrinsics]: dart.fnType(dart.void, [core.double]),
    [_computeChildrenHeightWithMinIntrinsics]: dart.fnType(dart.void, [core.double]),
    [_layoutText]: dart.fnType(dart.void, [], {maxWidth: core.double, minWidth: core.double}, {}),
    [_layoutTextWithConstraints]: dart.fnType(dart.void, [box.BoxConstraints]),
    [_layoutChildren]: dart.fnType(core.List$(text_painter.PlaceholderDimensions), [box.BoxConstraints], {dry: core.bool}, {}),
    [_setParentData]: dart.fnType(dart.void, []),
    [_canComputeDryLayout]: dart.fnType(core.bool, []),
    getOffsetForCaret: dart.fnType(ui.Offset, [ui.TextPosition, ui.Rect]),
    getFullHeightForCaret: dart.fnType(dart.nullable(core.double), [ui.TextPosition]),
    getBoxesForSelection: dart.fnType(core.List$(ui.TextBox), [text_editing.TextSelection]),
    getPositionForOffset: dart.fnType(ui.TextPosition, [ui.Offset]),
    getWordBoundary: dart.fnType(ui.TextRange, [ui.TextPosition])
  }));
  dart.setGetterSignature(paragraph.RenderParagraph, () => ({
    __proto__: dart.getGetters(paragraph.RenderParagraph.__proto__),
    text: inline_span.InlineSpan,
    [_placeholderSpans]: core.List$(placeholder_span.PlaceholderSpan),
    textAlign: ui.TextAlign,
    textDirection: ui.TextDirection,
    softWrap: core.bool,
    overflow: paragraph.TextOverflow,
    textScaleFactor: core.double,
    maxLines: dart.nullable(core.int),
    locale: dart.nullable(ui.Locale),
    strutStyle: dart.nullable(strut_style.StrutStyle),
    textWidthBasis: text_painter.TextWidthBasis,
    textHeightBehavior: dart.nullable(ui.TextHeightBehavior),
    debugHasOverflowShader: core.bool,
    textSize: ui.Size
  }));
  dart.setSetterSignature(paragraph.RenderParagraph, () => ({
    __proto__: dart.getSetters(paragraph.RenderParagraph.__proto__),
    text: inline_span.InlineSpan,
    [_placeholderSpans]: core.List$(placeholder_span.PlaceholderSpan),
    textAlign: ui.TextAlign,
    textDirection: ui.TextDirection,
    softWrap: core.bool,
    overflow: paragraph.TextOverflow,
    textScaleFactor: core.double,
    maxLines: dart.nullable(core.int),
    locale: dart.nullable(ui.Locale),
    strutStyle: dart.nullable(strut_style.StrutStyle),
    textWidthBasis: text_painter.TextWidthBasis,
    textHeightBehavior: dart.nullable(ui.TextHeightBehavior)
  }));
  dart.setLibraryUri(paragraph.RenderParagraph, I[0]);
  dart.setFieldSignature(paragraph.RenderParagraph, () => ({
    __proto__: dart.getFields(paragraph.RenderParagraph.__proto__),
    [_textPainter]: dart.finalFieldType(text_painter.TextPainter),
    [__RenderParagraph__placeholderSpans]: dart.fieldType(dart.nullable(core.List$(placeholder_span.PlaceholderSpan))),
    [_softWrap]: dart.fieldType(core.bool),
    [_overflow]: dart.fieldType(paragraph.TextOverflow),
    [_needsClipping]: dart.fieldType(core.bool),
    [_overflowShader]: dart.fieldType(dart.nullable(ui.Shader)),
    [_placeholderDimensions]: dart.fieldType(dart.nullable(core.List$(text_painter.PlaceholderDimensions))),
    [_semanticsInfo]: dart.fieldType(dart.nullable(core.List$(inline_span.InlineSpanSemanticsInformation))),
    [_cachedChildNodes]: dart.fieldType(dart.nullable(collection.Queue$(semantics.SemanticsNode)))
  }));
  dart.defineLazy(paragraph, {
    /*paragraph._kEllipsis*/get _kEllipsis() {
      return "…";
    }
  }, false);
  dart.trackLibraries("packages/flutter/src/rendering/paragraph.dart", {
    "package:flutter/src/rendering/paragraph.dart": paragraph
  }, {
  }, '{"version":3,"sourceRoot":"","sources":["paragraph.dart"],"names":[],"mappings":"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","file":"../../../../../../../packages/flutter/src/rendering/paragraph.dart.lib.js"}');
  // Exports:
  return {
    src__rendering__paragraph: paragraph
  };
}));

//# sourceMappingURL=paragraph.dart.lib.js.map
=======
  (box_border.BoxShape.new = function(index, _name) {
    this.index = index;
    this[_name$] = _name;
    ;
  }).prototype = box_border.BoxShape.prototype;
  dart.addTypeTests(box_border.BoxShape);
  dart.addTypeCaches(box_border.BoxShape);
  dart.setLibraryUri(box_border.BoxShape, I[0]);
  dart.setFieldSignature(box_border.BoxShape, () => ({
    __proto__: dart.getFields(box_border.BoxShape.__proto__),
    index: dart.finalFieldType(core.int),
    [_name$]: dart.finalFieldType(core.String)
  }));
  dart.defineExtensionMethods(box_border.BoxShape, ['toString']);
  box_border.BoxShape.rectangle = C[0] || CT.C0;
  box_border.BoxShape.circle = C[1] || CT.C1;
  box_border.BoxShape.values = C[2] || CT.C2;
  box_border.BoxBorder = class BoxBorder extends borders.ShapeBorder {
    add(other, opts) {
      let reversed = opts && 'reversed' in opts ? opts.reversed : false;
      return null;
    }
    static lerp(a, b, t) {
      if (!(t !== null)) dart.assertFailed(null, I[1], 106, 12, "t != null");
      if (T.BorderN().is(a) && T.BorderN().is(b)) return box_border.Border.lerp(a, b, t);
      if (T.BorderDirectionalN().is(a) && T.BorderDirectionalN().is(b)) return box_border.BorderDirectional.lerp(a, b, t);
      if (box_border.Border.is(b) && box_border.BorderDirectional.is(a)) {
        let c = b;
        b = a;
        a = c;
        t = 1.0 - t;
      }
      if (box_border.Border.is(a) && box_border.BorderDirectional.is(b)) {
        if (b.start._equals(borders.BorderSide.none) && b.end._equals(borders.BorderSide.none)) {
          return new box_border.Border.new({top: borders.BorderSide.lerp(a.top, b.top, t), right: borders.BorderSide.lerp(a.right, borders.BorderSide.none, t), bottom: borders.BorderSide.lerp(a.bottom, b.bottom, t), left: borders.BorderSide.lerp(a.left, borders.BorderSide.none, t)});
        }
        if (a.left._equals(borders.BorderSide.none) && a.right._equals(borders.BorderSide.none)) {
          return new box_border.BorderDirectional.new({top: borders.BorderSide.lerp(a.top, b.top, t), start: borders.BorderSide.lerp(borders.BorderSide.none, b.start, t), end: borders.BorderSide.lerp(borders.BorderSide.none, b.end, t), bottom: borders.BorderSide.lerp(a.bottom, b.bottom, t)});
        }
        if (t < 0.5) {
          return new box_border.Border.new({top: borders.BorderSide.lerp(a.top, b.top, t), right: borders.BorderSide.lerp(a.right, borders.BorderSide.none, t * 2.0), bottom: borders.BorderSide.lerp(a.bottom, b.bottom, t), left: borders.BorderSide.lerp(a.left, borders.BorderSide.none, t * 2.0)});
        }
        return new box_border.BorderDirectional.new({top: borders.BorderSide.lerp(a.top, b.top, t), start: borders.BorderSide.lerp(borders.BorderSide.none, b.start, (t - 0.5) * 2.0), end: borders.BorderSide.lerp(borders.BorderSide.none, b.end, (t - 0.5) * 2.0), bottom: borders.BorderSide.lerp(a.bottom, b.bottom, t)});
      }
      dart.throw(new assertions.FlutterError.fromParts(T.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("BoxBorder.lerp can only interpolate Border and BorderDirectional classes."), new assertions.ErrorDescription.new("BoxBorder.lerp() was called with two objects of type " + dart.str(dart.runtimeType(a)) + " and " + dart.str(dart.runtimeType(b)) + ":\n" + "  " + dart.str(a) + "\n" + "  " + dart.str(b) + "\n" + "However, only Border and BorderDirectional classes are supported by this method."), new assertions.ErrorHint.new("For a more general interpolation method, consider using ShapeBorder.lerp instead.")])));
    }
    getInnerPath(rect, opts) {
      let t0;
      let textDirection = opts && 'textDirection' in opts ? opts.textDirection : null;
      if (!(textDirection != null)) dart.assertFailed("The textDirection argument to " + dart.str(this[$runtimeType]) + ".getInnerPath must not be null.", I[1], 169, 12, "textDirection != null");
      t0 = ui.Path.new();
      return (() => {
        t0.addRect(this.dimensions.resolve(textDirection).deflateRect(rect));
        return t0;
      })();
    }
    getOuterPath(rect, opts) {
      let t0;
      let textDirection = opts && 'textDirection' in opts ? opts.textDirection : null;
      if (!(textDirection != null)) dart.assertFailed("The textDirection argument to " + dart.str(this[$runtimeType]) + ".getOuterPath must not be null.", I[1], 176, 12, "textDirection != null");
      t0 = ui.Path.new();
      return (() => {
        t0.addRect(rect);
        return t0;
      })();
    }
    static _paintUniformBorderWithRadius(canvas, rect, side, borderRadius) {
      let t0, t0$;
      if (!(side.style !== borders.BorderStyle.none)) dart.assertFailed(null, I[1], 210, 12, "side.style != BorderStyle.none");
      let paint = (t0 = ui.Paint.new(), (() => {
        t0.color = side.color;
        return t0;
      })());
      let outer = borderRadius.toRRect(rect);
      let width = side.width;
      if (width === 0.0) {
        t0$ = paint;
        (() => {
          t0$.style = ui.PaintingStyle.stroke;
          t0$.strokeWidth = 0.0;
          return t0$;
        })();
        canvas.drawRRect(outer, paint);
      } else {
        let inner = outer.deflate(width);
        canvas.drawDRRect(outer, inner, paint);
      }
    }
    static _paintUniformBorderWithCircle(canvas, rect, side) {
      if (!(side.style !== borders.BorderStyle.none)) dart.assertFailed(null, I[1], 227, 12, "side.style != BorderStyle.none");
      let width = side.width;
      let paint = side.toPaint();
      let radius = (rect.shortestSide - width) / 2.0;
      canvas.drawCircle(rect.center, radius, paint);
    }
    static _paintUniformBorderWithRectangle(canvas, rect, side) {
      if (!(side.style !== borders.BorderStyle.none)) dart.assertFailed(null, I[1], 235, 12, "side.style != BorderStyle.none");
      let width = side.width;
      let paint = side.toPaint();
      canvas.drawRect(rect.deflate(width / 2.0), paint);
    }
  };
  (box_border.BoxBorder.new = function() {
    box_border.BoxBorder.__proto__.new.call(this);
    ;
  }).prototype = box_border.BoxBorder.prototype;
  dart.addTypeTests(box_border.BoxBorder);
  dart.addTypeCaches(box_border.BoxBorder);
  dart.setMethodSignature(box_border.BoxBorder, () => ({
    __proto__: dart.getMethods(box_border.BoxBorder.__proto__),
    add: dart.fnType(dart.nullable(box_border.BoxBorder), [borders.ShapeBorder], {reversed: core.bool}, {}),
    getInnerPath: dart.fnType(ui.Path, [ui.Rect], {textDirection: dart.nullable(ui.TextDirection)}, {}),
    getOuterPath: dart.fnType(ui.Path, [ui.Rect], {textDirection: dart.nullable(ui.TextDirection)}, {})
  }));
  dart.setLibraryUri(box_border.BoxBorder, I[0]);
  var top$ = dart.privateName(box_border, "Border.top");
  var right$ = dart.privateName(box_border, "Border.right");
  var bottom$ = dart.privateName(box_border, "Border.bottom");
  var left$ = dart.privateName(box_border, "Border.left");
  var _name = dart.privateName(borders, "_name");
  var BorderSide_style = dart.privateName(borders, "BorderSide.style");
  var BorderSide_width = dart.privateName(borders, "BorderSide.width");
  var Color_value = dart.privateName(ui, "Color.value");
  var BorderSide_color = dart.privateName(borders, "BorderSide.color");
  var _colorIsUniform = dart.privateName(box_border, "_colorIsUniform");
  var _widthIsUniform = dart.privateName(box_border, "_widthIsUniform");
  var _styleIsUniform = dart.privateName(box_border, "_styleIsUniform");
  box_border.Border = class Border extends box_border.BoxBorder {
    get top() {
      return this[top$];
    }
    set top(value) {
      super.top = value;
    }
    get right() {
      return this[right$];
    }
    set right(value) {
      super.right = value;
    }
    get bottom() {
      return this[bottom$];
    }
    set bottom(value) {
      super.bottom = value;
    }
    get left() {
      return this[left$];
    }
    set left(value) {
      super.left = value;
    }
    static all(opts) {
      let color = opts && 'color' in opts ? opts.color : C[5] || CT.C5;
      let width = opts && 'width' in opts ? opts.width : 1;
      let style = opts && 'style' in opts ? opts.style : C[6] || CT.C6;
      let side = new borders.BorderSide.new({color: color, width: width, style: style});
      return new box_border.Border.fromBorderSide(side);
    }
    static merge(a, b) {
      if (!(a !== null)) dart.assertFailed(null, I[1], 365, 12, "a != null");
      if (!(b !== null)) dart.assertFailed(null, I[1], 366, 12, "b != null");
      if (!borders.BorderSide.canMerge(a.top, b.top)) dart.assertFailed(null, I[1], 367, 12, "BorderSide.canMerge(a.top, b.top)");
      if (!borders.BorderSide.canMerge(a.right, b.right)) dart.assertFailed(null, I[1], 368, 12, "BorderSide.canMerge(a.right, b.right)");
      if (!borders.BorderSide.canMerge(a.bottom, b.bottom)) dart.assertFailed(null, I[1], 369, 12, "BorderSide.canMerge(a.bottom, b.bottom)");
      if (!borders.BorderSide.canMerge(a.left, b.left)) dart.assertFailed(null, I[1], 370, 12, "BorderSide.canMerge(a.left, b.left)");
      return new box_border.Border.new({top: borders.BorderSide.merge(a.top, b.top), right: borders.BorderSide.merge(a.right, b.right), bottom: borders.BorderSide.merge(a.bottom, b.bottom), left: borders.BorderSide.merge(a.left, b.left)});
    }
    get dimensions() {
      return new edge_insets.EdgeInsets.fromLTRB(this.left.width, this.top.width, this.right.width, this.bottom.width);
    }
    get isUniform() {
      return this[_colorIsUniform] && this[_widthIsUniform] && this[_styleIsUniform];
    }
    get [_colorIsUniform]() {
      let topColor = this.top.color;
      return this.right.color._equals(topColor) && this.bottom.color._equals(topColor) && this.left.color._equals(topColor);
    }
    get [_widthIsUniform]() {
      let topWidth = this.top.width;
      return this.right.width === topWidth && this.bottom.width === topWidth && this.left.width === topWidth;
    }
    get [_styleIsUniform]() {
      let topStyle = this.top.style;
      return this.right.style === topStyle && this.bottom.style === topStyle && this.left.style === topStyle;
    }
    add(other, opts) {
      let reversed = opts && 'reversed' in opts ? opts.reversed : false;
      if (box_border.Border.is(other) && borders.BorderSide.canMerge(this.top, other.top) && borders.BorderSide.canMerge(this.right, other.right) && borders.BorderSide.canMerge(this.bottom, other.bottom) && borders.BorderSide.canMerge(this.left, other.left)) {
        return box_border.Border.merge(this, other);
      }
      return null;
    }
    scale(t) {
      return new box_border.Border.new({top: this.top.scale(t), right: this.right.scale(t), bottom: this.bottom.scale(t), left: this.left.scale(t)});
    }
    lerpFrom(a, t) {
      if (box_border.Border.is(a)) return box_border.Border.lerp(a, this, t);
      return super.lerpFrom(a, t);
    }
    lerpTo(b, t) {
      if (box_border.Border.is(b)) return box_border.Border.lerp(this, b, t);
      return super.lerpTo(b, t);
    }
    static lerp(a, b, t) {
      if (!(t !== null)) dart.assertFailed(null, I[1], 457, 12, "t != null");
      if (a == null && b == null) return null;
      if (a == null) return dart.nullCheck(b).scale(t);
      if (b == null) return a.scale(1.0 - t);
      return new box_border.Border.new({top: borders.BorderSide.lerp(a.top, b.top, t), right: borders.BorderSide.lerp(a.right, b.right, t), bottom: borders.BorderSide.lerp(a.bottom, b.bottom, t), left: borders.BorderSide.lerp(a.left, b.left, t)});
    }
    paint(canvas, rect, opts) {
      let textDirection = opts && 'textDirection' in opts ? opts.textDirection : null;
      let shape = opts && 'shape' in opts ? opts.shape : C[0] || CT.C0;
      let borderRadius = opts && 'borderRadius' in opts ? opts.borderRadius : null;
      if (this.isUniform) {
        switch (this.top.style) {
          case C[4] || CT.C4:
          {
            return;
          }
          case C[6] || CT.C6:
          {
            switch (shape) {
              case C[1] || CT.C1:
              {
                if (!(borderRadius == null)) dart.assertFailed("A borderRadius can only be given for rectangular boxes.", I[1], 506, 22, "borderRadius == null");
                box_border.BoxBorder._paintUniformBorderWithCircle(canvas, rect, this.top);
                break;
              }
              case C[0] || CT.C0:
              {
                if (borderRadius != null) {
                  box_border.BoxBorder._paintUniformBorderWithRadius(canvas, rect, this.top, borderRadius);
                  return;
                }
                box_border.BoxBorder._paintUniformBorderWithRectangle(canvas, rect, this.top);
                break;
              }
            }
            return;
          }
        }
      }
      if (!dart.fn(() => {
        if (borderRadius != null) {
          dart.throw(new assertions.FlutterError.fromParts((() => {
            let t0 = T.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("A borderRadius can only be given for a uniform Border."), new assertions.ErrorDescription.new("The following is not uniform:")]);
            if (!this[_colorIsUniform]) t0[$add](new assertions.ErrorDescription.new("BorderSide.color"));
            if (!this[_widthIsUniform]) t0[$add](new assertions.ErrorDescription.new("BorderSide.width"));
            if (!this[_styleIsUniform]) t0[$add](new assertions.ErrorDescription.new("BorderSide.style"));
            return t0;
          })()));
        }
        return true;
      }, T.VoidTobool())()) dart.assertFailed(null, I[1], 521, 12, "() {\r\n      if (borderRadius != null) {\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('A borderRadius can only be given for a uniform Border.'),\r\n          ErrorDescription('The following is not uniform:'),\r\n          if (!_colorIsUniform) ErrorDescription('BorderSide.color'),\r\n          if (!_widthIsUniform) ErrorDescription('BorderSide.width'),\r\n          if (!_styleIsUniform) ErrorDescription('BorderSide.style'),\r\n        ]);\r\n      }\r\n      return true;\r\n    }()");
      if (!dart.fn(() => {
        if (shape !== box_border.BoxShape.rectangle) {
          dart.throw(new assertions.FlutterError.fromParts((() => {
            let t1 = T.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("A Border can only be drawn as a circle if it is uniform"), new assertions.ErrorDescription.new("The following is not uniform:")]);
            if (!this[_colorIsUniform]) t1[$add](new assertions.ErrorDescription.new("BorderSide.color"));
            if (!this[_widthIsUniform]) t1[$add](new assertions.ErrorDescription.new("BorderSide.width"));
            if (!this[_styleIsUniform]) t1[$add](new assertions.ErrorDescription.new("BorderSide.style"));
            return t1;
          })()));
        }
        return true;
      }, T.VoidTobool())()) dart.assertFailed(null, I[1], 533, 12, "() {\r\n      if (shape != BoxShape.rectangle) {\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('A Border can only be drawn as a circle if it is uniform'),\r\n          ErrorDescription('The following is not uniform:'),\r\n          if (!_colorIsUniform) ErrorDescription('BorderSide.color'),\r\n          if (!_widthIsUniform) ErrorDescription('BorderSide.width'),\r\n          if (!_styleIsUniform) ErrorDescription('BorderSide.style'),\r\n        ]);\r\n      }\r\n      return true;\r\n    }()");
      borders.paintBorder(canvas, rect, {top: this.top, right: this.right, bottom: this.bottom, left: this.left});
    }
    _equals(other) {
      if (other == null) return false;
      if (this === other) return true;
      if (!other[$runtimeType]._equals(this[$runtimeType])) return false;
      return box_border.Border.is(other) && other.top._equals(this.top) && other.right._equals(this.right) && other.bottom._equals(this.bottom) && other.left._equals(this.left);
    }
    get hashCode() {
      return ui.hashValues(this.top, this.right, this.bottom, this.left);
    }
    toString() {
      if (this.isUniform) return object.objectRuntimeType(this, "Border") + ".all(" + dart.str(this.top) + ")";
      let $arguments = (() => {
        let t2 = T.JSArrayOfString().of([]);
        if (!this.top._equals(borders.BorderSide.none)) t2[$add]("top: " + dart.str(this.top));
        if (!this.right._equals(borders.BorderSide.none)) t2[$add]("right: " + dart.str(this.right));
        if (!this.bottom._equals(borders.BorderSide.none)) t2[$add]("bottom: " + dart.str(this.bottom));
        if (!this.left._equals(borders.BorderSide.none)) t2[$add]("left: " + dart.str(this.left));
        return t2;
      })();
      return object.objectRuntimeType(this, "Border") + "(" + $arguments[$join](", ") + ")";
    }
  };
  (box_border.Border.new = function(opts) {
    let top = opts && 'top' in opts ? opts.top : C[3] || CT.C3;
    let right = opts && 'right' in opts ? opts.right : C[3] || CT.C3;
    let bottom = opts && 'bottom' in opts ? opts.bottom : C[3] || CT.C3;
    let left = opts && 'left' in opts ? opts.left : C[3] || CT.C3;
    this[top$] = top;
    this[right$] = right;
    this[bottom$] = bottom;
    this[left$] = left;
    if (!(top !== null)) dart.assertFailed(null, I[1], 314, 15, "top != null");
    if (!(right !== null)) dart.assertFailed(null, I[1], 315, 15, "right != null");
    if (!(bottom !== null)) dart.assertFailed(null, I[1], 316, 15, "bottom != null");
    if (!(left !== null)) dart.assertFailed(null, I[1], 317, 15, "left != null");
    box_border.Border.__proto__.new.call(this);
    ;
  }).prototype = box_border.Border.prototype;
  (box_border.Border.fromBorderSide = function(side) {
    if (!(side !== null)) dart.assertFailed(null, I[1], 323, 16, "side != null");
    this[top$] = side;
    this[right$] = side;
    this[bottom$] = side;
    this[left$] = side;
    box_border.Border.__proto__.new.call(this);
    ;
  }).prototype = box_border.Border.prototype;
  (box_border.Border.symmetric = function(opts) {
    let vertical = opts && 'vertical' in opts ? opts.vertical : C[3] || CT.C3;
    let horizontal = opts && 'horizontal' in opts ? opts.horizontal : C[3] || CT.C3;
    if (!(vertical !== null)) dart.assertFailed(null, I[1], 338, 15, "vertical != null");
    if (!(horizontal !== null)) dart.assertFailed(null, I[1], 339, 15, "horizontal != null");
    this[left$] = vertical;
    this[top$] = horizontal;
    this[right$] = vertical;
    this[bottom$] = horizontal;
    box_border.Border.__proto__.new.call(this);
    ;
  }).prototype = box_border.Border.prototype;
  dart.addTypeTests(box_border.Border);
  dart.addTypeCaches(box_border.Border);
  dart.setMethodSignature(box_border.Border, () => ({
    __proto__: dart.getMethods(box_border.Border.__proto__),
    add: dart.fnType(dart.nullable(box_border.Border), [borders.ShapeBorder], {reversed: core.bool}, {}),
    scale: dart.fnType(box_border.Border, [core.double]),
    paint: dart.fnType(dart.void, [ui.Canvas, ui.Rect], {borderRadius: dart.nullable(border_radius.BorderRadius), shape: box_border.BoxShape, textDirection: dart.nullable(ui.TextDirection)}, {})
  }));
  dart.setGetterSignature(box_border.Border, () => ({
    __proto__: dart.getGetters(box_border.Border.__proto__),
    dimensions: edge_insets.EdgeInsetsGeometry,
    isUniform: core.bool,
    [_colorIsUniform]: core.bool,
    [_widthIsUniform]: core.bool,
    [_styleIsUniform]: core.bool
  }));
  dart.setLibraryUri(box_border.Border, I[0]);
  dart.setFieldSignature(box_border.Border, () => ({
    __proto__: dart.getFields(box_border.Border.__proto__),
    top: dart.finalFieldType(borders.BorderSide),
    right: dart.finalFieldType(borders.BorderSide),
    bottom: dart.finalFieldType(borders.BorderSide),
    left: dart.finalFieldType(borders.BorderSide)
  }));
  dart.defineExtensionMethods(box_border.Border, ['_equals', 'toString']);
  dart.defineExtensionAccessors(box_border.Border, ['hashCode']);
  var top$0 = dart.privateName(box_border, "BorderDirectional.top");
  var start$ = dart.privateName(box_border, "BorderDirectional.start");
  var end$ = dart.privateName(box_border, "BorderDirectional.end");
  var bottom$0 = dart.privateName(box_border, "BorderDirectional.bottom");
  var _name$0 = dart.privateName(ui, "_name");
  box_border.BorderDirectional = class BorderDirectional extends box_border.BoxBorder {
    get top() {
      return this[top$0];
    }
    set top(value) {
      super.top = value;
    }
    get start() {
      return this[start$];
    }
    set start(value) {
      super.start = value;
    }
    get end() {
      return this[end$];
    }
    set end(value) {
      super.end = value;
    }
    get bottom() {
      return this[bottom$0];
    }
    set bottom(value) {
      super.bottom = value;
    }
    static merge(a, b) {
      if (!(a !== null)) dart.assertFailed(null, I[1], 626, 12, "a != null");
      if (!(b !== null)) dart.assertFailed(null, I[1], 627, 12, "b != null");
      if (!borders.BorderSide.canMerge(a.top, b.top)) dart.assertFailed(null, I[1], 628, 12, "BorderSide.canMerge(a.top, b.top)");
      if (!borders.BorderSide.canMerge(a.start, b.start)) dart.assertFailed(null, I[1], 629, 12, "BorderSide.canMerge(a.start, b.start)");
      if (!borders.BorderSide.canMerge(a.end, b.end)) dart.assertFailed(null, I[1], 630, 12, "BorderSide.canMerge(a.end, b.end)");
      if (!borders.BorderSide.canMerge(a.bottom, b.bottom)) dart.assertFailed(null, I[1], 631, 12, "BorderSide.canMerge(a.bottom, b.bottom)");
      return new box_border.BorderDirectional.new({top: borders.BorderSide.merge(a.top, b.top), start: borders.BorderSide.merge(a.start, b.start), end: borders.BorderSide.merge(a.end, b.end), bottom: borders.BorderSide.merge(a.bottom, b.bottom)});
    }
    get dimensions() {
      return new edge_insets.EdgeInsetsDirectional.fromSTEB(this.start.width, this.top.width, this.end.width, this.bottom.width);
    }
    get isUniform() {
      let topColor = this.top.color;
      if (!this.start.color._equals(topColor) || !this.end.color._equals(topColor) || !this.bottom.color._equals(topColor)) return false;
      let topWidth = this.top.width;
      if (this.start.width !== topWidth || this.end.width !== topWidth || this.bottom.width !== topWidth) return false;
      let topStyle = this.top.style;
      if (this.start.style !== topStyle || this.end.style !== topStyle || this.bottom.style !== topStyle) return false;
      return true;
    }
    add(other, opts) {
      let reversed = opts && 'reversed' in opts ? opts.reversed : false;
      if (box_border.BorderDirectional.is(other)) {
        let typedOther = other;
        if (borders.BorderSide.canMerge(this.top, typedOther.top) && borders.BorderSide.canMerge(this.start, typedOther.start) && borders.BorderSide.canMerge(this.end, typedOther.end) && borders.BorderSide.canMerge(this.bottom, typedOther.bottom)) {
          return box_border.BorderDirectional.merge(this, typedOther);
        }
        return null;
      }
      if (box_border.Border.is(other)) {
        let typedOther = other;
        if (!borders.BorderSide.canMerge(typedOther.top, this.top) || !borders.BorderSide.canMerge(typedOther.bottom, this.bottom)) return null;
        if (!this.start._equals(borders.BorderSide.none) || !this.end._equals(borders.BorderSide.none)) {
          if (!typedOther.left._equals(borders.BorderSide.none) || !typedOther.right._equals(borders.BorderSide.none)) return null;
          if (!typedOther.left._equals(borders.BorderSide.none)) dart.assertFailed(null, I[1], 716, 16, "typedOther.left == BorderSide.none");
          if (!typedOther.right._equals(borders.BorderSide.none)) dart.assertFailed(null, I[1], 717, 16, "typedOther.right == BorderSide.none");
          return new box_border.BorderDirectional.new({top: borders.BorderSide.merge(typedOther.top, this.top), start: this.start, end: this.end, bottom: borders.BorderSide.merge(typedOther.bottom, this.bottom)});
        }
        if (!this.start._equals(borders.BorderSide.none)) dart.assertFailed(null, I[1], 725, 14, "start == BorderSide.none");
        if (!this.end._equals(borders.BorderSide.none)) dart.assertFailed(null, I[1], 726, 14, "end == BorderSide.none");
        return new box_border.Border.new({top: borders.BorderSide.merge(typedOther.top, this.top), right: typedOther.right, bottom: borders.BorderSide.merge(typedOther.bottom, this.bottom), left: typedOther.left});
      }
      return null;
    }
    scale(t) {
      return new box_border.BorderDirectional.new({top: this.top.scale(t), start: this.start.scale(t), end: this.end.scale(t), bottom: this.bottom.scale(t)});
    }
    lerpFrom(a, t) {
      if (box_border.BorderDirectional.is(a)) return box_border.BorderDirectional.lerp(a, this, t);
      return super.lerpFrom(a, t);
    }
    lerpTo(b, t) {
      if (box_border.BorderDirectional.is(b)) return box_border.BorderDirectional.lerp(this, b, t);
      return super.lerpTo(b, t);
    }
    static lerp(a, b, t) {
      if (!(t !== null)) dart.assertFailed(null, I[1], 768, 12, "t != null");
      if (a == null && b == null) return null;
      if (a == null) return dart.nullCheck(b).scale(t);
      if (b == null) return a.scale(1.0 - t);
      return new box_border.BorderDirectional.new({top: borders.BorderSide.lerp(a.top, b.top, t), end: borders.BorderSide.lerp(a.end, b.end, t), bottom: borders.BorderSide.lerp(a.bottom, b.bottom, t), start: borders.BorderSide.lerp(a.start, b.start, t)});
    }
    paint(canvas, rect, opts) {
      let textDirection = opts && 'textDirection' in opts ? opts.textDirection : null;
      let shape = opts && 'shape' in opts ? opts.shape : C[0] || CT.C0;
      let borderRadius = opts && 'borderRadius' in opts ? opts.borderRadius : null;
      if (this.isUniform) {
        switch (this.top.style) {
          case C[4] || CT.C4:
          {
            return;
          }
          case C[6] || CT.C6:
          {
            switch (shape) {
              case C[1] || CT.C1:
              {
                if (!(borderRadius == null)) dart.assertFailed("A borderRadius can only be given for rectangular boxes.", I[1], 820, 22, "borderRadius == null");
                box_border.BoxBorder._paintUniformBorderWithCircle(canvas, rect, this.top);
                break;
              }
              case C[0] || CT.C0:
              {
                if (borderRadius != null) {
                  box_border.BoxBorder._paintUniformBorderWithRadius(canvas, rect, this.top, borderRadius);
                  return;
                }
                box_border.BoxBorder._paintUniformBorderWithRectangle(canvas, rect, this.top);
                break;
              }
            }
            return;
          }
        }
      }
      if (!(borderRadius == null)) dart.assertFailed("A borderRadius can only be given for uniform borders.", I[1], 835, 12, "borderRadius == null");
      if (!(shape === box_border.BoxShape.rectangle)) dart.assertFailed("A border can only be drawn as a circle if it is uniform.", I[1], 836, 12, "shape == BoxShape.rectangle");
      let left = null;
      let right = null;
      if (!(textDirection != null)) dart.assertFailed("Non-uniform BorderDirectional objects require a TextDirection when painting.", I[1], 839, 12, "textDirection != null");
      switch (dart.nullCheck(textDirection)) {
        case C[7] || CT.C7:
        {
          left = this.end;
          right = this.start;
          break;
        }
        case C[8] || CT.C8:
        {
          left = this.start;
          right = this.end;
          break;
        }
      }
      borders.paintBorder(canvas, rect, {top: this.top, left: left, bottom: this.bottom, right: right});
    }
    _equals(other) {
      if (other == null) return false;
      if (this === other) return true;
      if (!other[$runtimeType]._equals(this[$runtimeType])) return false;
      return box_border.BorderDirectional.is(other) && other.top._equals(this.top) && other.start._equals(this.start) && other.end._equals(this.end) && other.bottom._equals(this.bottom);
    }
    get hashCode() {
      return ui.hashValues(this.top, this.start, this.end, this.bottom);
    }
    toString() {
      let $arguments = (() => {
        let t3 = T.JSArrayOfString().of([]);
        if (!this.top._equals(borders.BorderSide.none)) t3[$add]("top: " + dart.str(this.top));
        if (!this.start._equals(borders.BorderSide.none)) t3[$add]("start: " + dart.str(this.start));
        if (!this.end._equals(borders.BorderSide.none)) t3[$add]("end: " + dart.str(this.end));
        if (!this.bottom._equals(borders.BorderSide.none)) t3[$add]("bottom: " + dart.str(this.bottom));
        return t3;
      })();
      return object.objectRuntimeType(this, "BorderDirectional") + "(" + $arguments[$join](", ") + ")";
    }
  };
  (box_border.BorderDirectional.new = function(opts) {
    let top = opts && 'top' in opts ? opts.top : C[3] || CT.C3;
    let start = opts && 'start' in opts ? opts.start : C[3] || CT.C3;
    let end = opts && 'end' in opts ? opts.end : C[3] || CT.C3;
    let bottom = opts && 'bottom' in opts ? opts.bottom : C[3] || CT.C3;
    this[top$0] = top;
    this[start$] = start;
    this[end$] = end;
    this[bottom$0] = bottom;
    if (!(top !== null)) dart.assertFailed(null, I[1], 613, 15, "top != null");
    if (!(start !== null)) dart.assertFailed(null, I[1], 614, 15, "start != null");
    if (!(end !== null)) dart.assertFailed(null, I[1], 615, 15, "end != null");
    if (!(bottom !== null)) dart.assertFailed(null, I[1], 616, 15, "bottom != null");
    box_border.BorderDirectional.__proto__.new.call(this);
    ;
  }).prototype = box_border.BorderDirectional.prototype;
  dart.addTypeTests(box_border.BorderDirectional);
  dart.addTypeCaches(box_border.BorderDirectional);
  dart.setMethodSignature(box_border.BorderDirectional, () => ({
    __proto__: dart.getMethods(box_border.BorderDirectional.__proto__),
    scale: dart.fnType(box_border.BorderDirectional, [core.double]),
    paint: dart.fnType(dart.void, [ui.Canvas, ui.Rect], {borderRadius: dart.nullable(border_radius.BorderRadius), shape: box_border.BoxShape, textDirection: dart.nullable(ui.TextDirection)}, {})
  }));
  dart.setGetterSignature(box_border.BorderDirectional, () => ({
    __proto__: dart.getGetters(box_border.BorderDirectional.__proto__),
    dimensions: edge_insets.EdgeInsetsGeometry,
    isUniform: core.bool
  }));
  dart.setLibraryUri(box_border.BorderDirectional, I[0]);
  dart.setFieldSignature(box_border.BorderDirectional, () => ({
    __proto__: dart.getFields(box_border.BorderDirectional.__proto__),
    top: dart.finalFieldType(borders.BorderSide),
    start: dart.finalFieldType(borders.BorderSide),
    end: dart.finalFieldType(borders.BorderSide),
    bottom: dart.finalFieldType(borders.BorderSide)
  }));
  dart.defineExtensionMethods(box_border.BorderDirectional, ['_equals', 'toString']);
  dart.defineExtensionAccessors(box_border.BorderDirectional, ['hashCode']);
  dart.trackLibraries("packages/flutter/src/painting/box_border.dart", {
    "package:flutter/src/painting/box_border.dart": box_border
  }, {
  }, '{"version":3,"sourceRoot":"","sources":["box_border.dart"],"names":[],"mappings":"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","file":"../../../../../../../packages/flutter/src/painting/box_border.dart.lib.js"}');
  // Exports:
  return {
    src__painting__box_border: box_border
  };
}));

//# sourceMappingURL=box_border.dart.lib.js.map
>>>>>>> 75a5b68328961ba989f4b72e23f0c2c5b16d7dc4
